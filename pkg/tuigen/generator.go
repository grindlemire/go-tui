package tuigen

import (
	"bytes"
	"fmt"
	"go/format"
	"strconv"
)

// Generator transforms a validated AST into Go source code.
type Generator struct {
	buf        bytes.Buffer
	indent     int
	varCounter int
	sourceFile string // original .tui filename for header comment
}

// NewGenerator creates a new code generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate produces Go source code from a parsed and analyzed AST.
// Returns the generated code as a byte slice, or an error if generation fails.
func (g *Generator) Generate(file *File, sourceFile string) ([]byte, error) {
	g.buf.Reset()
	g.varCounter = 0
	g.sourceFile = sourceFile

	// Generate header
	g.generateHeader()

	// Generate package
	g.generatePackage(file.Package)

	// Generate imports
	g.generateImports(file.Imports)

	// Generate top-level Go functions
	for _, fn := range file.Funcs {
		g.generateGoFunc(fn)
	}

	// Generate components
	for _, comp := range file.Components {
		g.generateComponent(comp)
	}

	// Format the output with gofmt
	return format.Source(g.buf.Bytes())
}

// generateHeader writes the "DO NOT EDIT" comment.
func (g *Generator) generateHeader() {
	g.writeln("// Code generated by tui generate. DO NOT EDIT.")
	if g.sourceFile != "" {
		g.writef("// Source: %s\n", g.sourceFile)
	}
	g.writeln("")
}

// generatePackage writes the package declaration.
func (g *Generator) generatePackage(pkg string) {
	g.writef("package %s\n\n", pkg)
}

// generateImports writes the import block.
func (g *Generator) generateImports(imports []Import) {
	if len(imports) == 0 {
		// Always include element import for generated code
		g.writeln("import (")
		g.indent++
		g.writeln(`"github.com/grindlemire/go-tui/pkg/tui/element"`)
		g.indent--
		g.writeln(")")
		g.writeln("")
		return
	}

	// Check if element is already imported
	hasElement := false
	for _, imp := range imports {
		if imp.Path == "github.com/grindlemire/go-tui/pkg/tui/element" {
			hasElement = true
			break
		}
	}

	g.writeln("import (")
	g.indent++

	for _, imp := range imports {
		if imp.Alias != "" {
			g.writef("%s %q\n", imp.Alias, imp.Path)
		} else {
			g.writef("%q\n", imp.Path)
		}
	}

	// Add element import if not present
	if !hasElement {
		g.writeln("")
		g.writeln(`"github.com/grindlemire/go-tui/pkg/tui/element"`)
	}

	g.indent--
	g.writeln(")")
	g.writeln("")
}

// generateComponent generates a Go function from a component.
func (g *Generator) generateComponent(comp *Component) {
	// Reset variable counter for each component
	g.varCounter = 0

	// Generate function signature
	g.writef("func %s(", comp.Name)
	for i, param := range comp.Params {
		if i > 0 {
			g.write(", ")
		}
		g.writef("%s %s", param.Name, param.Type)
	}
	// Add children parameter if component accepts children
	if comp.AcceptsChildren {
		if len(comp.Params) > 0 {
			g.write(", ")
		}
		g.write("children []*element.Element")
	}
	g.writef(") %s {\n", comp.ReturnType)
	g.indent++

	// Track the root element variable name
	// The root is the first top-level Element (not LetBinding, which is typically a child reference)
	var rootVar string

	// Generate body nodes
	for _, node := range comp.Body {
		switch n := node.(type) {
		case *Element:
			varName := g.generateElement(n, "")
			if rootVar == "" {
				rootVar = varName
			}
		case *LetBinding:
			// @let bindings create elements that are typically used as children
			// They are NOT the root element unless explicitly used
			g.generateLetBinding(n, "")
		case *ForLoop:
			g.generateForLoop(n, "")
		case *IfStmt:
			g.generateIfStmt(n, "")
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			// A bare expression in component body - treat as statement
			g.writef("%s\n", n.Code)
		case *ComponentCall:
			varName := g.generateComponentCall(n, "")
			if rootVar == "" {
				rootVar = varName
			}
		}
	}

	// Return the root element
	if rootVar != "" {
		g.writef("return %s\n", rootVar)
	} else {
		// No element found, return nil
		g.writeln("return nil")
	}

	g.indent--
	g.writeln("}")
	g.writeln("")
}

// generateElement generates code for an element and returns the variable name.
// If parentVar is non-empty, adds this element as a child.
func (g *Generator) generateElement(elem *Element, parentVar string) string {
	varName := g.nextVar()

	// Build options from attributes and tag
	options := g.buildElementOptions(elem)

	// Generate element creation
	if len(options) == 0 {
		g.writef("%s := element.New()\n", varName)
	} else {
		g.writef("%s := element.New(\n", varName)
		g.indent++
		for _, opt := range options {
			g.writef("%s,\n", opt)
		}
		g.indent--
		g.writeln(")")
	}

	// Generate children - skip if text element already has content in WithText
	if !skipTextChildren(elem) {
		g.generateChildren(varName, elem.Children)
	}

	// Add to parent if specified
	if parentVar != "" {
		g.writef("%s.AddChild(%s)\n", parentVar, varName)
	}

	return varName
}

// buildElementOptions generates option expressions for an element.
func (g *Generator) buildElementOptions(elem *Element) []string {
	var options []string

	// Handle tag-specific options
	switch elem.Tag {
	case "hr":
		options = append(options, "element.WithHR()")
	case "br":
		options = append(options, "element.WithWidth(0)")
		options = append(options, "element.WithHeight(1)")
	case "span", "p":
		// If text element has children that are text content, add WithText
		textContent := g.extractTextContent(elem.Children)
		if textContent != "" {
			options = append(options, fmt.Sprintf("element.WithText(%s)", textContent))
		}
	}

	// Track text style methods from class attribute separately
	var classTextMethods []string

	// Generate options from attributes
	for _, attr := range elem.Attributes {
		// Handle class attribute specially - parse Tailwind classes
		if attr.Name == "class" {
			classValue := g.getClassAttributeValue(attr)
			if classValue != "" {
				result := ParseTailwindClasses(classValue)
				// Add direct options
				options = append(options, result.Options...)
				// Collect text style methods for combining later
				classTextMethods = append(classTextMethods, result.TextMethods...)
			}
			continue
		}

		opt := g.generateAttributeOption(attr)
		if opt != "" {
			options = append(options, opt)
		}
	}

	// Build combined text style from class attribute if any
	if len(classTextMethods) > 0 {
		textStyleOpt := BuildTextStyleOption(classTextMethods)
		if textStyleOpt != "" {
			options = append(options, textStyleOpt)
		}
	}

	return options
}

// getClassAttributeValue extracts the string value from a class attribute.
func (g *Generator) getClassAttributeValue(attr *Attribute) string {
	switch v := attr.Value.(type) {
	case *StringLit:
		return v.Value
	default:
		// class attribute only supports string literals for now
		return ""
	}
}

// extractTextContent extracts text from element children for WithText.
// Returns empty string if children contain non-text content.
func (g *Generator) extractTextContent(children []Node) string {
	if len(children) == 0 {
		return ""
	}

	// If single GoExpr child, return the expression
	if len(children) == 1 {
		if expr, ok := children[0].(*GoExpr); ok {
			return expr.Code
		}
		if text, ok := children[0].(*TextContent); ok {
			return strconv.Quote(text.Text)
		}
	}

	// Multiple children or complex content - handled separately in generateChildren
	return ""
}

// attributeToOption maps DSL attribute names to element.With* functions.
var attributeToOption = map[string]string{
	// Dimensions
	"width":         "element.WithWidth(%s)",
	"widthPercent":  "element.WithWidthPercent(%s)",
	"height":        "element.WithHeight(%s)",
	"heightPercent": "element.WithHeightPercent(%s)",
	"minWidth":      "element.WithMinWidth(%s)",
	"minHeight":     "element.WithMinHeight(%s)",
	"maxWidth":      "element.WithMaxWidth(%s)",
	"maxHeight":     "element.WithMaxHeight(%s)",

	// Flex container
	"direction": "element.WithDirection(%s)",
	"justify":   "element.WithJustify(%s)",
	"align":     "element.WithAlign(%s)",
	"gap":       "element.WithGap(%s)",

	// Flex item
	"flexGrow":   "element.WithFlexGrow(%s)",
	"flexShrink": "element.WithFlexShrink(%s)",
	"alignSelf":  "element.WithAlignSelf(%s)",

	// Spacing
	"padding": "element.WithPadding(%s)",
	"margin":  "element.WithMargin(%s)",

	// Visual
	"border":      "element.WithBorder(%s)",
	"borderStyle": "element.WithBorderStyle(%s)",
	"background":  "element.WithBackground(%s)",

	// Text
	"text":      "element.WithText(%s)",
	"textStyle": "element.WithTextStyle(%s)",
	"textAlign": "element.WithTextAlign(%s)",

	// Focus
	"onFocus": "element.WithOnFocus(%s)",
	"onBlur":  "element.WithOnBlur(%s)",
	"onEvent": "element.WithOnEvent(%s)",

	// Scroll
	"scrollable": "element.WithScrollable(%s)",
}

// generateAttributeOption generates an option expression from an attribute.
func (g *Generator) generateAttributeOption(attr *Attribute) string {
	template, ok := attributeToOption[attr.Name]
	if !ok {
		// Unknown attribute - skip with no error (analyzer should catch this)
		return ""
	}

	value := g.generateAttributeValue(attr.Value)
	return fmt.Sprintf(template, value)
}

// generateAttributeValue generates a Go expression from an attribute value.
func (g *Generator) generateAttributeValue(value Node) string {
	switch v := value.(type) {
	case *StringLit:
		return strconv.Quote(v.Value)
	case *IntLit:
		return strconv.FormatInt(v.Value, 10)
	case *FloatLit:
		return strconv.FormatFloat(v.Value, 'f', -1, 64)
	case *BoolLit:
		if v.Value {
			return "true"
		}
		return "false"
	case *GoExpr:
		return v.Code
	case *RawGoExpr:
		return v.Code
	default:
		return ""
	}
}

// generateChildren generates code for element children.
func (g *Generator) generateChildren(parentVar string, children []Node) {
	for _, child := range children {
		switch c := child.(type) {
		case *Element:
			g.generateElement(c, parentVar)
		case *LetBinding:
			g.generateLetBinding(c, parentVar)
		case *ForLoop:
			g.generateForLoop(c, parentVar)
		case *IfStmt:
			g.generateIfStmt(c, parentVar)
		case *GoExpr:
			// GoExpr as child - create text element with the expression
			varName := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", varName, c.Code)
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		case *TextContent:
			// TextContent as child - create text element
			varName := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", varName, strconv.Quote(c.Text))
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		case *RawGoExpr:
			// RawGoExpr is a variable reference - add directly
			g.writef("%s.AddChild(%s)\n", parentVar, c.Code)
		case *ComponentCall:
			g.generateComponentCall(c, parentVar)
		case *ChildrenSlot:
			// Expand the children parameter
			g.writeln("for _, __child := range children {")
			g.indent++
			g.writef("%s.AddChild(__child)\n", parentVar)
			g.indent--
			g.writeln("}")
		}
	}
}

// generateLetBinding generates code for a @let binding.
func (g *Generator) generateLetBinding(let *LetBinding, parentVar string) {
	// Generate the element with a specific variable name
	options := g.buildElementOptions(let.Element)

	if len(options) == 0 {
		g.writef("%s := element.New()\n", let.Name)
	} else {
		g.writef("%s := element.New(\n", let.Name)
		g.indent++
		for _, opt := range options {
			g.writef("%s,\n", opt)
		}
		g.indent--
		g.writeln(")")
	}

	// Generate children for the let-bound element - skip if text element already has content in WithText
	if !skipTextChildren(let.Element) {
		g.generateChildren(let.Name, let.Element.Children)
	}

	// Add to parent if specified
	if parentVar != "" {
		g.writef("%s.AddChild(%s)\n", parentVar, let.Name)
	}
}

// generateForLoop generates code for a @for loop.
func (g *Generator) generateForLoop(loop *ForLoop, parentVar string) {
	// Build loop header
	var loopVars string
	if loop.Index != "" {
		loopVars = fmt.Sprintf("%s, %s", loop.Index, loop.Value)
	} else {
		loopVars = loop.Value
	}

	g.writef("for %s := range %s {\n", loopVars, loop.Iterable)
	g.indent++

	// Silence unused variable warnings if index is not used
	if loop.Index != "" && loop.Index != "_" {
		g.writef("_ = %s\n", loop.Index)
	}

	// Generate loop body
	for _, node := range loop.Body {
		switch n := node.(type) {
		case *Element:
			g.generateElement(n, parentVar)
		case *LetBinding:
			g.generateLetBinding(n, parentVar)
		case *ForLoop:
			g.generateForLoop(n, parentVar)
		case *IfStmt:
			g.generateIfStmt(n, parentVar)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			// Bare expression in loop body
			if parentVar != "" {
				varName := g.nextVar()
				g.writef("%s := element.New(element.WithText(%s))\n", varName, n.Code)
				g.writef("%s.AddChild(%s)\n", parentVar, varName)
			} else {
				g.writef("%s\n", n.Code)
			}
		case *ComponentCall:
			g.generateComponentCall(n, parentVar)
		case *ChildrenSlot:
			if parentVar != "" {
				g.writeln("for _, __child := range children {")
				g.indent++
				g.writef("%s.AddChild(__child)\n", parentVar)
				g.indent--
				g.writeln("}")
			}
		}
	}

	g.indent--
	g.writeln("}")
}

// generateIfStmt generates code for an @if statement.
func (g *Generator) generateIfStmt(stmt *IfStmt, parentVar string) {
	g.writef("if %s {\n", stmt.Condition)
	g.indent++

	// Generate then body
	for _, node := range stmt.Then {
		g.generateBodyNode(node, parentVar)
	}

	g.indent--

	// Generate else branch if present
	if len(stmt.Else) > 0 {
		g.write("} else ")

		// Check if else contains a single IfStmt (else-if chain)
		if len(stmt.Else) == 1 {
			if elseIf, ok := stmt.Else[0].(*IfStmt); ok {
				g.generateIfStmt(elseIf, parentVar)
				return
			}
		}

		g.writeln("{")
		g.indent++
		for _, node := range stmt.Else {
			g.generateBodyNode(node, parentVar)
		}
		g.indent--
		g.writeln("}")
	} else {
		g.writeln("}")
	}
}

// generateBodyNode generates code for a node in a component/control flow body.
func (g *Generator) generateBodyNode(node Node, parentVar string) {
	switch n := node.(type) {
	case *Element:
		g.generateElement(n, parentVar)
	case *LetBinding:
		g.generateLetBinding(n, parentVar)
	case *ForLoop:
		g.generateForLoop(n, parentVar)
	case *IfStmt:
		g.generateIfStmt(n, parentVar)
	case *GoCode:
		g.generateGoCode(n)
	case *GoExpr:
		if parentVar != "" {
			varName := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", varName, n.Code)
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		} else {
			g.writef("%s\n", n.Code)
		}
	case *TextContent:
		if parentVar != "" {
			varName := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", varName, strconv.Quote(n.Text))
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		}
	case *RawGoExpr:
		if parentVar != "" {
			g.writef("%s.AddChild(%s)\n", parentVar, n.Code)
		}
	case *ComponentCall:
		g.generateComponentCall(n, parentVar)
	case *ChildrenSlot:
		if parentVar != "" {
			g.writeln("for _, __child := range children {")
			g.indent++
			g.writef("%s.AddChild(__child)\n", parentVar)
			g.indent--
			g.writeln("}")
		}
	}
}

// generateGoCode generates a raw Go statement.
func (g *Generator) generateGoCode(gc *GoCode) {
	g.writef("%s\n", gc.Code)
}

// generateGoFunc generates a top-level Go function.
func (g *Generator) generateGoFunc(fn *GoFunc) {
	g.writef("%s\n\n", fn.Code)
}

// generateComponentCall generates code for a component call.
// Returns the variable name holding the result.
func (g *Generator) generateComponentCall(call *ComponentCall, parentVar string) string {
	varName := g.nextVar()

	if len(call.Children) == 0 {
		// No children - simple call
		if call.Args == "" {
			g.writef("%s := %s(nil)\n", varName, call.Name)
		} else {
			g.writef("%s := %s(%s, nil)\n", varName, call.Name, call.Args)
		}
	} else {
		// Has children - build children slice first
		childrenVar := g.nextVar() + "_children"
		g.writef("%s := []*element.Element{}\n", childrenVar)

		// Generate each child and append to slice
		for _, child := range call.Children {
			switch c := child.(type) {
			case *Element:
				elemVar := g.generateElement(c, "")
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *ComponentCall:
				innerVar := g.generateComponentCall(c, "")
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, innerVar)
			case *LetBinding:
				g.generateLetBinding(c, "")
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, c.Name)
			case *ForLoop:
				// For loops generate multiple elements - use a temp slice
				g.generateForLoopForSlice(c, childrenVar)
			case *IfStmt:
				// If statements may or may not generate elements
				g.generateIfStmtForSlice(c, childrenVar)
			case *GoExpr:
				// Expression - wrap in text element
				elemVar := g.nextVar()
				g.writef("%s := element.New(element.WithText(%s))\n", elemVar, c.Code)
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *TextContent:
				elemVar := g.nextVar()
				g.writef("%s := element.New(element.WithText(%s))\n", elemVar, strconv.Quote(c.Text))
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *RawGoExpr:
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, c.Code)
			}
		}

		// Call component with children
		if call.Args == "" {
			g.writef("%s := %s(%s)\n", varName, call.Name, childrenVar)
		} else {
			g.writef("%s := %s(%s, %s)\n", varName, call.Name, call.Args, childrenVar)
		}
	}

	// Add to parent if specified
	if parentVar != "" {
		g.writef("%s.AddChild(%s)\n", parentVar, varName)
	}

	return varName
}

// generateForLoopForSlice generates a for loop that appends elements to a slice.
func (g *Generator) generateForLoopForSlice(loop *ForLoop, sliceVar string) {
	var loopVars string
	if loop.Index != "" {
		loopVars = fmt.Sprintf("%s, %s", loop.Index, loop.Value)
	} else {
		loopVars = loop.Value
	}

	g.writef("for %s := range %s {\n", loopVars, loop.Iterable)
	g.indent++

	if loop.Index != "" && loop.Index != "_" {
		g.writef("_ = %s\n", loop.Index)
	}

	for _, node := range loop.Body {
		switch n := node.(type) {
		case *Element:
			elemVar := g.generateElement(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		case *ComponentCall:
			callVar := g.generateComponentCall(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, callVar)
		case *LetBinding:
			g.generateLetBinding(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
		case *ForLoop:
			g.generateForLoopForSlice(n, sliceVar)
		case *IfStmt:
			g.generateIfStmtForSlice(n, sliceVar)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			elemVar := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", elemVar, n.Code)
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		}
	}

	g.indent--
	g.writeln("}")
}

// generateIfStmtForSlice generates an if statement that appends elements to a slice.
func (g *Generator) generateIfStmtForSlice(stmt *IfStmt, sliceVar string) {
	g.writef("if %s {\n", stmt.Condition)
	g.indent++

	for _, node := range stmt.Then {
		switch n := node.(type) {
		case *Element:
			elemVar := g.generateElement(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		case *ComponentCall:
			callVar := g.generateComponentCall(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, callVar)
		case *LetBinding:
			g.generateLetBinding(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
		case *ForLoop:
			g.generateForLoopForSlice(n, sliceVar)
		case *IfStmt:
			g.generateIfStmtForSlice(n, sliceVar)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			elemVar := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", elemVar, n.Code)
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		}
	}

	g.indent--

	if len(stmt.Else) > 0 {
		g.write("} else ")

		if len(stmt.Else) == 1 {
			if elseIf, ok := stmt.Else[0].(*IfStmt); ok {
				g.generateIfStmtForSlice(elseIf, sliceVar)
				return
			}
		}

		g.writeln("{")
		g.indent++
		for _, node := range stmt.Else {
			switch n := node.(type) {
			case *Element:
				elemVar := g.generateElement(n, "")
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
			case *ComponentCall:
				callVar := g.generateComponentCall(n, "")
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, callVar)
			case *LetBinding:
				g.generateLetBinding(n, "")
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
			case *ForLoop:
				g.generateForLoopForSlice(n, sliceVar)
			case *IfStmt:
				g.generateIfStmtForSlice(n, sliceVar)
			case *GoCode:
				g.generateGoCode(n)
			case *GoExpr:
				elemVar := g.nextVar()
				g.writef("%s := element.New(element.WithText(%s))\n", elemVar, n.Code)
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
			}
		}
		g.indent--
		g.writeln("}")
	} else {
		g.writeln("}")
	}
}

// nextVar returns the next unique variable name.
func (g *Generator) nextVar() string {
	name := fmt.Sprintf("__tui_%d", g.varCounter)
	g.varCounter++
	return name
}

// write writes a string without indentation.
func (g *Generator) write(s string) {
	g.buf.WriteString(s)
}

// writef writes a formatted string with indentation.
func (g *Generator) writef(format string, args ...interface{}) {
	g.writeIndent()
	fmt.Fprintf(&g.buf, format, args...)
}

// writeln writes a line with indentation.
func (g *Generator) writeln(s string) {
	if s == "" {
		g.buf.WriteByte('\n')
		return
	}
	g.writeIndent()
	g.buf.WriteString(s)
	g.buf.WriteByte('\n')
}

// writeIndent writes the current indentation.
func (g *Generator) writeIndent() {
	for i := 0; i < g.indent; i++ {
		g.buf.WriteByte('\t')
	}
}

// GenerateString is a convenience method that returns the generated code as a string.
func (g *Generator) GenerateString(file *File, sourceFile string) (string, error) {
	data, err := g.Generate(file, sourceFile)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// ParseAndGenerate parses source code and generates Go code in one step.
// This is a convenience function for simple use cases.
func ParseAndGenerate(filename, source string) ([]byte, error) {
	lexer := NewLexer(filename, source)
	parser := NewParser(lexer)

	file, err := parser.ParseFile()
	if err != nil {
		return nil, err
	}

	gen := NewGenerator()
	return gen.Generate(file, filename)
}

// textElementWithOptions checks if this is a text element that needs options
// extracted from its children for WithText.
func textElementWithOptions(elem *Element) bool {
	if elem.Tag != "span" && elem.Tag != "p" {
		return false
	}
	// Has text content that should go into WithText
	for _, child := range elem.Children {
		switch child.(type) {
		case *TextContent, *GoExpr:
			return true
		}
	}
	return false
}

// skipTextChildren returns true if text element children should not be
// processed as AddChild calls (they're already in WithText).
func skipTextChildren(elem *Element) bool {
	if elem.Tag != "span" && elem.Tag != "p" {
		return false
	}
	// Only skip if there's a single text/expr child that was used for WithText
	if len(elem.Children) != 1 {
		return false
	}
	switch elem.Children[0].(type) {
	case *TextContent, *GoExpr:
		return true
	}
	return false
}

// GenerateToBuffer generates code and writes it to the buffer.
// This avoids an extra allocation compared to Generate().
func (g *Generator) GenerateToBuffer(buf *bytes.Buffer, file *File, sourceFile string) error {
	data, err := g.Generate(file, sourceFile)
	if err != nil {
		return err
	}
	buf.Write(data)
	return nil
}
