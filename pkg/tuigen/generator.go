package tuigen

import (
	"bytes"
	"fmt"
	"strconv"

	"golang.org/x/tools/imports"
)

// Generator transforms a validated AST into Go source code.
type Generator struct {
	buf        bytes.Buffer
	indent     int
	varCounter int
	sourceFile string // original .tui filename for header comment

	// Named refs tracking for current component
	namedRefs []NamedRef

	// Watcher expressions for current component (onChannel/onTimer)
	watchers []string

	// Component calls with watchers that need aggregation
	componentVars []string

	// State tracking for current component (for reactive bindings)
	stateVars     []StateVar
	stateBindings []StateBinding
}

// NewGenerator creates a new code generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate produces Go source code from a parsed and analyzed AST.
// Returns the generated code as a byte slice, or an error if generation fails.
func (g *Generator) Generate(file *File, sourceFile string) ([]byte, error) {
	g.buf.Reset()
	g.varCounter = 0
	g.sourceFile = sourceFile

	// Generate header
	g.generateHeader()

	// Generate package
	g.generatePackage(file.Package)

	// Generate imports
	g.generateImports(file.Imports)

	// Generate top-level Go functions
	for _, fn := range file.Funcs {
		g.generateGoFunc(fn)
	}

	// Generate components
	for _, comp := range file.Components {
		g.generateComponent(comp)
	}

	// Format and fix imports with goimports
	return imports.Process(g.sourceFile, g.buf.Bytes(), nil)
}

// generateHeader writes the "DO NOT EDIT" comment.
func (g *Generator) generateHeader() {
	g.writeln("// Code generated by tui generate. DO NOT EDIT.")
	if g.sourceFile != "" {
		g.writef("// Source: %s\n", g.sourceFile)
	}
	g.writeln("")
}

// generatePackage writes the package declaration.
func (g *Generator) generatePackage(pkg string) {
	g.writef("package %s\n\n", pkg)
}

// generateImports writes the import block.
func (g *Generator) generateImports(imports []Import) {
	if len(imports) == 0 {
		// Always include element and tui imports for generated code
		g.writeln("import (")
		g.indent++
		g.writeln(`"github.com/grindlemire/go-tui/pkg/tui"`)
		g.writeln(`"github.com/grindlemire/go-tui/pkg/tui/element"`)
		g.indent--
		g.writeln(")")
		g.writeln("")
		return
	}

	// Check if element and tui are already imported
	hasElement := false
	hasTui := false
	for _, imp := range imports {
		if imp.Path == "github.com/grindlemire/go-tui/pkg/tui/element" {
			hasElement = true
		}
		if imp.Path == "github.com/grindlemire/go-tui/pkg/tui" {
			hasTui = true
		}
	}

	g.writeln("import (")
	g.indent++

	for _, imp := range imports {
		if imp.Alias != "" {
			g.writef("%s %q\n", imp.Alias, imp.Path)
		} else {
			g.writef("%q\n", imp.Path)
		}
	}

	// Add required imports if not present
	needsSeparator := !hasElement || !hasTui
	if needsSeparator {
		g.writeln("")
	}
	if !hasTui {
		g.writeln(`"github.com/grindlemire/go-tui/pkg/tui"`)
	}
	if !hasElement {
		g.writeln(`"github.com/grindlemire/go-tui/pkg/tui/element"`)
	}

	g.indent--
	g.writeln(")")
	g.writeln("")
}

// generateComponent generates a Go function from a component.
func (g *Generator) generateComponent(comp *Component) {
	// Reset variable counter and watcher tracking for each component
	g.varCounter = 0
	g.watchers = nil
	g.componentVars = nil
	g.stateVars = nil
	g.stateBindings = nil

	// Collect named refs from this component
	analyzer := NewAnalyzer()
	g.namedRefs = analyzer.CollectNamedRefs(comp)

	// Detect state variables and bindings
	g.stateVars = analyzer.DetectStateVars(comp)
	g.stateBindings = analyzer.DetectStateBindings(comp, g.stateVars)

	// Generate view struct for this component (always generated)
	structName := comp.Name + "View"
	g.generateViewStruct(comp.Name, g.namedRefs)

	// Generate function signature - always returns struct
	g.writef("func %s(", comp.Name)
	for i, param := range comp.Params {
		if i > 0 {
			g.write(", ")
		}
		g.writef("%s %s", param.Name, param.Type)
	}
	// Add children parameter if component accepts children
	if comp.AcceptsChildren {
		if len(comp.Params) > 0 {
			g.write(", ")
		}
		g.write("children []*element.Element")
	}
	g.writef(") %s {\n", structName)
	g.indent++

	// Pre-declare view variable so closures can capture it
	g.writef("var view %s\n", structName)
	g.writeln("var watchers []tui.Watcher")
	g.writeln("")

	// Declare slice/map variables at function scope for loop refs
	for _, ref := range g.namedRefs {
		if ref.InLoop {
			if ref.KeyExpr != "" {
				g.writef("%s := make(map[%s]*element.Element)\n", ref.Name, ref.KeyType)
			} else {
				g.writef("var %s []*element.Element\n", ref.Name)
			}
		}
	}

	// Declare pointer variables at function scope for conditional refs (not in loops)
	for _, ref := range g.namedRefs {
		if ref.InConditional && !ref.InLoop {
			g.writef("var %s *element.Element\n", ref.Name)
		}
	}

	// Add blank line after declarations if we had any
	hasLoopRefs := false
	hasCondRefs := false
	for _, ref := range g.namedRefs {
		if ref.InLoop {
			hasLoopRefs = true
		}
		if ref.InConditional && !ref.InLoop {
			hasCondRefs = true
		}
	}
	if hasLoopRefs || hasCondRefs {
		g.writeln("")
	}

	// Track the root element variable name
	// The root is the first top-level Element (not LetBinding, which is typically a child reference)
	var rootVar string
	var rootRef string       // Named ref on root element, if any
	var rootIsComponent bool // Whether root is a component call (needs .Root accessor)

	// Generate body nodes
	for _, node := range comp.Body {
		switch n := node.(type) {
		case *Element:
			varName := g.generateElementWithRefs(n, "", false, false)
			if rootVar == "" {
				rootVar = varName
				if n.NamedRef != "" {
					rootRef = n.NamedRef
				}
			}
		case *LetBinding:
			// @let bindings create elements that are typically used as children
			// They are NOT the root element unless explicitly used
			g.generateLetBinding(n, "")
		case *ForLoop:
			g.generateForLoopWithRefs(n, "", false)
		case *IfStmt:
			g.generateIfStmtWithRefs(n, "", false)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			// A bare expression in component body - treat as statement
			g.writef("%s\n", n.Code)
		case *ComponentCall:
			varName := g.generateComponentCallWithRefs(n, "")
			if rootVar == "" {
				rootVar = varName
				rootIsComponent = true
			}
		}
	}

	// Emit watcher collection statements (collected during element generation)
	if len(g.watchers) > 0 || len(g.componentVars) > 0 {
		g.writeln("")
		// Append watchers from onChannel/onTimer attributes
		for _, watcher := range g.watchers {
			g.writef("watchers = append(watchers, %s)\n", watcher)
		}
		// Aggregate watchers from child component calls
		for _, compVar := range g.componentVars {
			g.writef("watchers = append(watchers, %s.GetWatchers()...)\n", compVar)
		}
	}

	// Generate state bindings (reactive updates)
	g.generateStateBindings()

	// Populate view struct before returning
	g.writeln("")
	g.writef("view = %s{\n", structName)
	g.indent++
	if rootVar != "" {
		if rootIsComponent {
			g.writef("Root: %s.Root,\n", rootVar)
		} else {
			g.writef("Root: %s,\n", rootVar)
		}
	} else {
		g.writeln("Root: nil,")
	}
	g.writeln("watchers: watchers,")
	for _, ref := range g.namedRefs {
		// If this ref is on the root element, point to rootVar
		if ref.Name == rootRef {
			g.writef("%s: %s,\n", ref.Name, rootVar)
		} else {
			g.writef("%s: %s,\n", ref.Name, ref.Name)
		}
	}
	g.indent--
	g.writeln("}")

	g.writeln("return view")

	g.indent--
	g.writeln("}")
	g.writeln("")
}

// generateViewStruct generates the ComponentNameView struct definition.
func (g *Generator) generateViewStruct(compName string, refs []NamedRef) {
	structName := compName + "View"

	g.writef("type %s struct {\n", structName)
	g.indent++
	g.writeln("Root     *element.Element")
	g.writeln("watchers []tui.Watcher")

	for _, ref := range refs {
		if ref.InLoop {
			if ref.KeyExpr != "" {
				// Map type for keyed refs
				g.writef("%s map[%s]*element.Element\n", ref.Name, ref.KeyType)
			} else {
				// Slice type for unkeyed loop refs
				g.writef("%s []*element.Element\n", ref.Name)
			}
		} else if ref.InConditional {
			g.writef("%s *element.Element // may be nil\n", ref.Name)
		} else {
			g.writef("%s *element.Element\n", ref.Name)
		}
	}

	g.indent--
	g.writeln("}")
	g.writeln("")

	// Generate GetRoot() method to implement tui.Viewable
	g.writef("func (v %s) GetRoot() tui.Renderable { return v.Root }\n", structName)
	g.writeln("")

	// Generate GetWatchers() method to implement tui.Viewable
	g.writef("func (v %s) GetWatchers() []tui.Watcher { return v.watchers }\n", structName)
	g.writeln("")
}

// generateElement generates code for an element and returns the variable name.
// If parentVar is non-empty, adds this element as a child.
func (g *Generator) generateElement(elem *Element, parentVar string) string {
	return g.generateElementWithRefs(elem, parentVar, false, false)
}

// generateElementWithRefs generates code for an element with named ref handling.
// inLoop and inConditional track the context for proper variable handling.
func (g *Generator) generateElementWithRefs(elem *Element, parentVar string, inLoop bool, inConditional bool) string {
	// Determine variable name - use ref name if it's a named ref
	var varName string
	if elem.NamedRef != "" {
		// For refs in loops or conditionals, the variable is already declared at function scope
		if inLoop || inConditional {
			varName = g.nextVar() // Use temp var, then assign/append to ref variable
		} else {
			varName = elem.NamedRef // Use ref name directly
		}
	} else {
		varName = g.nextVar()
	}

	// Build options from attributes and tag
	options := g.buildElementOptions(elem)

	// Generate element creation
	if len(options) == 0 {
		g.writef("%s := element.New()\n", varName)
	} else {
		g.writef("%s := element.New(\n", varName)
		g.indent++
		for _, opt := range options {
			g.writef("%s,\n", opt)
		}
		g.indent--
		g.writeln(")")
	}

	// Handle named ref assignment in loops/conditionals
	if elem.NamedRef != "" {
		if inLoop {
			if elem.RefKey != nil {
				// Map-based ref: assign to map with key
				g.writef("%s[%s] = %s\n", elem.NamedRef, elem.RefKey.Code, varName)
			} else {
				// Slice-based ref: append to slice
				g.writef("%s = append(%s, %s)\n", elem.NamedRef, elem.NamedRef, varName)
			}
		} else if inConditional {
			// Conditional ref: assign to pre-declared variable
			g.writef("%s = %s\n", elem.NamedRef, varName)
		}
	}

	// Generate children - skip if text element already has content in WithText
	if !skipTextChildren(elem) {
		g.generateChildrenWithRefs(varName, elem.Children, inLoop, inConditional)
	}

	// Add to parent if specified
	if parentVar != "" {
		g.writef("%s.AddChild(%s)\n", parentVar, varName)
	}

	return varName
}

// buildElementOptions generates option expressions for an element.
func (g *Generator) buildElementOptions(elem *Element) []string {
	var options []string

	// Handle tag-specific options
	switch elem.Tag {
	case "hr":
		options = append(options, "element.WithHR()")
	case "br":
		options = append(options, "element.WithWidth(0)")
		options = append(options, "element.WithHeight(1)")
	case "span", "p":
		// If text element has children that are text content, add WithText
		textContent := g.extractTextContent(elem.Children)
		if textContent != "" {
			options = append(options, fmt.Sprintf("element.WithText(%s)", textContent))
		}
	}

	// Track text style methods from class attribute separately
	var classTextMethods []string

	// Generate options from attributes
	for _, attr := range elem.Attributes {
		// Handle class attribute specially - parse Tailwind classes
		if attr.Name == "class" {
			classValue := g.getClassAttributeValue(attr)
			if classValue != "" {
				result := ParseTailwindClasses(classValue)
				// Add direct options
				options = append(options, result.Options...)
				// Collect text style methods for combining later
				classTextMethods = append(classTextMethods, result.TextMethods...)
			}
			continue
		}

		// Handle onChannel and onTimer specially - they are watchers, not element options
		if attr.Name == "onChannel" || attr.Name == "onTimer" {
			watcherExpr := g.generateAttributeValue(attr.Value)
			if watcherExpr != "" {
				g.watchers = append(g.watchers, watcherExpr)
			}
			continue
		}

		opt := g.generateAttributeOption(attr)
		if opt != "" {
			options = append(options, opt)
		}
	}

	// Build combined text style from class attribute if any
	if len(classTextMethods) > 0 {
		textStyleOpt := BuildTextStyleOption(classTextMethods)
		if textStyleOpt != "" {
			options = append(options, textStyleOpt)
		}
	}

	return options
}

// getClassAttributeValue extracts the string value from a class attribute.
func (g *Generator) getClassAttributeValue(attr *Attribute) string {
	switch v := attr.Value.(type) {
	case *StringLit:
		return v.Value
	default:
		// class attribute only supports string literals for now
		return ""
	}
}

// extractTextContent extracts text from element children for WithText.
// Returns empty string if children contain non-text content.
func (g *Generator) extractTextContent(children []Node) string {
	if len(children) == 0 {
		return ""
	}

	// If single GoExpr child, return the expression
	if len(children) == 1 {
		if expr, ok := children[0].(*GoExpr); ok {
			return expr.Code
		}
		if text, ok := children[0].(*TextContent); ok {
			return strconv.Quote(text.Text)
		}
	}

	// Multiple children or complex content - handled separately in generateChildren
	return ""
}

// attributeToOption maps DSL attribute names to element.With* functions.
var attributeToOption = map[string]string{
	// Dimensions
	"width":         "element.WithWidth(%s)",
	"widthPercent":  "element.WithWidthPercent(%s)",
	"height":        "element.WithHeight(%s)",
	"heightPercent": "element.WithHeightPercent(%s)",
	"minWidth":      "element.WithMinWidth(%s)",
	"minHeight":     "element.WithMinHeight(%s)",
	"maxWidth":      "element.WithMaxWidth(%s)",
	"maxHeight":     "element.WithMaxHeight(%s)",

	// Flex container
	"direction": "element.WithDirection(%s)",
	"justify":   "element.WithJustify(%s)",
	"align":     "element.WithAlign(%s)",
	"gap":       "element.WithGap(%s)",

	// Flex item
	"flexGrow":   "element.WithFlexGrow(%s)",
	"flexShrink": "element.WithFlexShrink(%s)",
	"alignSelf":  "element.WithAlignSelf(%s)",

	// Spacing
	"padding": "element.WithPadding(%s)",
	"margin":  "element.WithMargin(%s)",

	// Visual
	"border":      "element.WithBorder(%s)",
	"borderStyle": "element.WithBorderStyle(%s)",
	"background":  "element.WithBackground(%s)",

	// Text
	"text":      "element.WithText(%s)",
	"textStyle": "element.WithTextStyle(%s)",
	"textAlign": "element.WithTextAlign(%s)",

	// Focus
	"onFocus":   "element.WithOnFocus(%s)",
	"onBlur":    "element.WithOnBlur(%s)",
	"onEvent":   "element.WithOnEvent(%s)",
	"focusable": "element.WithFocusable(%s)",

	// Event handlers (no bool return)
	"onKeyPress": "element.WithOnKeyPress(%s)",
	"onClick":    "element.WithOnClick(%s)",

	// Scroll
	"scrollable": "element.WithScrollable(%s)",
}

// generateAttributeOption generates an option expression from an attribute.
func (g *Generator) generateAttributeOption(attr *Attribute) string {
	template, ok := attributeToOption[attr.Name]
	if !ok {
		// Unknown attribute - skip with no error (analyzer should catch this)
		return ""
	}

	value := g.generateAttributeValue(attr.Value)
	return fmt.Sprintf(template, value)
}

// generateAttributeValue generates a Go expression from an attribute value.
func (g *Generator) generateAttributeValue(value Node) string {
	switch v := value.(type) {
	case *StringLit:
		return strconv.Quote(v.Value)
	case *IntLit:
		return strconv.FormatInt(v.Value, 10)
	case *FloatLit:
		return strconv.FormatFloat(v.Value, 'f', -1, 64)
	case *BoolLit:
		if v.Value {
			return "true"
		}
		return "false"
	case *GoExpr:
		return v.Code
	case *RawGoExpr:
		return v.Code
	default:
		return ""
	}
}

// generateChildren generates code for element children.
func (g *Generator) generateChildren(parentVar string, children []Node) {
	g.generateChildrenWithRefs(parentVar, children, false, false)
}

// generateChildrenWithRefs generates code for element children with ref context tracking.
func (g *Generator) generateChildrenWithRefs(parentVar string, children []Node, inLoop bool, inConditional bool) {
	for _, child := range children {
		switch c := child.(type) {
		case *Element:
			g.generateElementWithRefs(c, parentVar, inLoop, inConditional)
		case *LetBinding:
			g.generateLetBinding(c, parentVar)
		case *ForLoop:
			g.generateForLoopWithRefs(c, parentVar, inConditional)
		case *IfStmt:
			g.generateIfStmtWithRefs(c, parentVar, inLoop)
		case *GoExpr:
			// GoExpr as child - create text element with the expression
			varName := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", varName, c.Code)
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		case *TextContent:
			// TextContent as child - create text element
			varName := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", varName, strconv.Quote(c.Text))
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		case *RawGoExpr:
			// RawGoExpr is a variable reference - add directly
			g.writef("%s.AddChild(%s)\n", parentVar, c.Code)
		case *ComponentCall:
			g.generateComponentCallWithRefs(c, parentVar)
		case *ChildrenSlot:
			// Expand the children parameter
			g.writeln("for _, __child := range children {")
			g.indent++
			g.writef("%s.AddChild(__child)\n", parentVar)
			g.indent--
			g.writeln("}")
		}
	}
}

// generateLetBinding generates code for a @let binding.
func (g *Generator) generateLetBinding(let *LetBinding, parentVar string) {
	// Generate the element with a specific variable name
	options := g.buildElementOptions(let.Element)

	if len(options) == 0 {
		g.writef("%s := element.New()\n", let.Name)
	} else {
		g.writef("%s := element.New(\n", let.Name)
		g.indent++
		for _, opt := range options {
			g.writef("%s,\n", opt)
		}
		g.indent--
		g.writeln(")")
	}

	// Generate children for the let-bound element - skip if text element already has content in WithText
	if !skipTextChildren(let.Element) {
		g.generateChildren(let.Name, let.Element.Children)
	}

	// Add to parent if specified
	if parentVar != "" {
		g.writef("%s.AddChild(%s)\n", parentVar, let.Name)
	}
}

// generateForLoop generates code for a @for loop.
func (g *Generator) generateForLoop(loop *ForLoop, parentVar string) {
	g.generateForLoopWithRefs(loop, parentVar, false)
}

// generateForLoopWithRefs generates code for a @for loop with ref context tracking.
func (g *Generator) generateForLoopWithRefs(loop *ForLoop, parentVar string, inConditional bool) {
	// Build loop header
	var loopVars string
	if loop.Index != "" {
		loopVars = fmt.Sprintf("%s, %s", loop.Index, loop.Value)
	} else {
		loopVars = loop.Value
	}

	g.writef("for %s := range %s {\n", loopVars, loop.Iterable)
	g.indent++

	// Silence unused variable warnings if index is not used
	if loop.Index != "" && loop.Index != "_" {
		g.writef("_ = %s\n", loop.Index)
	}

	// Generate loop body - now inside a loop context
	for _, node := range loop.Body {
		switch n := node.(type) {
		case *Element:
			g.generateElementWithRefs(n, parentVar, true, inConditional)
		case *LetBinding:
			g.generateLetBinding(n, parentVar)
		case *ForLoop:
			g.generateForLoopWithRefs(n, parentVar, inConditional)
		case *IfStmt:
			g.generateIfStmtWithRefs(n, parentVar, true) // now in loop context
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			// Bare expression in loop body
			if parentVar != "" {
				varName := g.nextVar()
				g.writef("%s := element.New(element.WithText(%s))\n", varName, n.Code)
				g.writef("%s.AddChild(%s)\n", parentVar, varName)
			} else {
				g.writef("%s\n", n.Code)
			}
		case *ComponentCall:
			g.generateComponentCallWithRefs(n, parentVar)
		case *ChildrenSlot:
			if parentVar != "" {
				g.writeln("for _, __child := range children {")
				g.indent++
				g.writef("%s.AddChild(__child)\n", parentVar)
				g.indent--
				g.writeln("}")
			}
		}
	}

	g.indent--
	g.writeln("}")
}

// generateIfStmt generates code for an @if statement.
func (g *Generator) generateIfStmt(stmt *IfStmt, parentVar string) {
	g.generateIfStmtWithRefs(stmt, parentVar, false)
}

// generateIfStmtWithRefs generates code for an @if statement with ref context tracking.
func (g *Generator) generateIfStmtWithRefs(stmt *IfStmt, parentVar string, inLoop bool) {
	g.writef("if %s {\n", stmt.Condition)
	g.indent++

	// Generate then body - now inside conditional context
	for _, node := range stmt.Then {
		g.generateBodyNodeWithRefs(node, parentVar, inLoop, true)
	}

	g.indent--

	// Generate else branch if present
	if len(stmt.Else) > 0 {
		g.write("} else ")

		// Check if else contains a single IfStmt (else-if chain)
		if len(stmt.Else) == 1 {
			if elseIf, ok := stmt.Else[0].(*IfStmt); ok {
				g.generateIfStmtWithRefs(elseIf, parentVar, inLoop)
				return
			}
		}

		g.writeln("{")
		g.indent++
		for _, node := range stmt.Else {
			g.generateBodyNodeWithRefs(node, parentVar, inLoop, true)
		}
		g.indent--
		g.writeln("}")
	} else {
		g.writeln("}")
	}
}

// generateBodyNode generates code for a node in a component/control flow body.
func (g *Generator) generateBodyNode(node Node, parentVar string) {
	g.generateBodyNodeWithRefs(node, parentVar, false, false)
}

// generateBodyNodeWithRefs generates code for a node with ref context tracking.
func (g *Generator) generateBodyNodeWithRefs(node Node, parentVar string, inLoop bool, inConditional bool) {
	switch n := node.(type) {
	case *Element:
		g.generateElementWithRefs(n, parentVar, inLoop, inConditional)
	case *LetBinding:
		g.generateLetBinding(n, parentVar)
	case *ForLoop:
		g.generateForLoopWithRefs(n, parentVar, inConditional)
	case *IfStmt:
		g.generateIfStmtWithRefs(n, parentVar, inLoop)
	case *GoCode:
		g.generateGoCode(n)
	case *GoExpr:
		if parentVar != "" {
			varName := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", varName, n.Code)
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		} else {
			g.writef("%s\n", n.Code)
		}
	case *TextContent:
		if parentVar != "" {
			varName := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", varName, strconv.Quote(n.Text))
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		}
	case *RawGoExpr:
		if parentVar != "" {
			g.writef("%s.AddChild(%s)\n", parentVar, n.Code)
		}
	case *ComponentCall:
		g.generateComponentCallWithRefs(n, parentVar)
	case *ChildrenSlot:
		if parentVar != "" {
			g.writeln("for _, __child := range children {")
			g.indent++
			g.writef("%s.AddChild(__child)\n", parentVar)
			g.indent--
			g.writeln("}")
		}
	}
}

// generateGoCode generates a raw Go statement.
func (g *Generator) generateGoCode(gc *GoCode) {
	g.writef("%s\n", gc.Code)
}

// generateGoFunc generates a top-level Go function.
func (g *Generator) generateGoFunc(fn *GoFunc) {
	g.writef("%s\n\n", fn.Code)
}

// generateComponentCall generates code for a component call.
// Returns the variable name holding the result.
func (g *Generator) generateComponentCall(call *ComponentCall, parentVar string) string {
	return g.generateComponentCallWithRefs(call, parentVar)
}

// generateComponentCallWithRefs generates code for a component call.
// Returns the variable name holding the result.
func (g *Generator) generateComponentCallWithRefs(call *ComponentCall, parentVar string) string {
	varName := g.nextVar()

	if len(call.Children) == 0 {
		// No children - simple call, returns view struct
		if call.Args == "" {
			g.writef("%s := %s()\n", varName, call.Name)
		} else {
			g.writef("%s := %s(%s)\n", varName, call.Name, call.Args)
		}
	} else {
		// Has children - build children slice first
		childrenVar := g.nextVar() + "_children"
		g.writef("%s := []*element.Element{}\n", childrenVar)

		// Generate each child and append to slice
		for _, child := range call.Children {
			switch c := child.(type) {
			case *Element:
				elemVar := g.generateElement(c, "")
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *ComponentCall:
				innerVar := g.generateComponentCallWithRefs(c, "")
				g.writef("%s = append(%s, %s.Root)\n", childrenVar, childrenVar, innerVar)
			case *LetBinding:
				g.generateLetBinding(c, "")
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, c.Name)
			case *ForLoop:
				// For loops generate multiple elements - use a temp slice
				g.generateForLoopForSlice(c, childrenVar)
			case *IfStmt:
				// If statements may or may not generate elements
				g.generateIfStmtForSlice(c, childrenVar)
			case *GoExpr:
				// Expression - wrap in text element
				elemVar := g.nextVar()
				g.writef("%s := element.New(element.WithText(%s))\n", elemVar, c.Code)
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *TextContent:
				elemVar := g.nextVar()
				g.writef("%s := element.New(element.WithText(%s))\n", elemVar, strconv.Quote(c.Text))
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *RawGoExpr:
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, c.Code)
			}
		}

		// Call component with children
		if call.Args == "" {
			g.writef("%s := %s(%s)\n", varName, call.Name, childrenVar)
		} else {
			g.writef("%s := %s(%s, %s)\n", varName, call.Name, call.Args, childrenVar)
		}
	}

	// Track this component call for watcher aggregation
	g.componentVars = append(g.componentVars, varName)

	// Add to parent if specified - use .Root to get the element from the view struct
	if parentVar != "" {
		g.writef("%s.AddChild(%s.Root)\n", parentVar, varName)
	}

	return varName
}

// generateForLoopForSlice generates a for loop that appends elements to a slice.
func (g *Generator) generateForLoopForSlice(loop *ForLoop, sliceVar string) {
	var loopVars string
	if loop.Index != "" {
		loopVars = fmt.Sprintf("%s, %s", loop.Index, loop.Value)
	} else {
		loopVars = loop.Value
	}

	g.writef("for %s := range %s {\n", loopVars, loop.Iterable)
	g.indent++

	if loop.Index != "" && loop.Index != "_" {
		g.writef("_ = %s\n", loop.Index)
	}

	for _, node := range loop.Body {
		switch n := node.(type) {
		case *Element:
			elemVar := g.generateElement(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		case *ComponentCall:
			callVar := g.generateComponentCallWithRefs(n, "")
			g.writef("%s = append(%s, %s.Root)\n", sliceVar, sliceVar, callVar)
		case *LetBinding:
			g.generateLetBinding(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
		case *ForLoop:
			g.generateForLoopForSlice(n, sliceVar)
		case *IfStmt:
			g.generateIfStmtForSlice(n, sliceVar)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			elemVar := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", elemVar, n.Code)
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		}
	}

	g.indent--
	g.writeln("}")
}

// generateIfStmtForSlice generates an if statement that appends elements to a slice.
func (g *Generator) generateIfStmtForSlice(stmt *IfStmt, sliceVar string) {
	g.writef("if %s {\n", stmt.Condition)
	g.indent++

	for _, node := range stmt.Then {
		switch n := node.(type) {
		case *Element:
			elemVar := g.generateElement(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		case *ComponentCall:
			callVar := g.generateComponentCallWithRefs(n, "")
			g.writef("%s = append(%s, %s.Root)\n", sliceVar, sliceVar, callVar)
		case *LetBinding:
			g.generateLetBinding(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
		case *ForLoop:
			g.generateForLoopForSlice(n, sliceVar)
		case *IfStmt:
			g.generateIfStmtForSlice(n, sliceVar)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			elemVar := g.nextVar()
			g.writef("%s := element.New(element.WithText(%s))\n", elemVar, n.Code)
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		}
	}

	g.indent--

	if len(stmt.Else) > 0 {
		g.write("} else ")

		if len(stmt.Else) == 1 {
			if elseIf, ok := stmt.Else[0].(*IfStmt); ok {
				g.generateIfStmtForSlice(elseIf, sliceVar)
				return
			}
		}

		g.writeln("{")
		g.indent++
		for _, node := range stmt.Else {
			switch n := node.(type) {
			case *Element:
				elemVar := g.generateElement(n, "")
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
			case *ComponentCall:
				callVar := g.generateComponentCallWithRefs(n, "")
				g.writef("%s = append(%s, %s.Root)\n", sliceVar, sliceVar, callVar)
			case *LetBinding:
				g.generateLetBinding(n, "")
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
			case *ForLoop:
				g.generateForLoopForSlice(n, sliceVar)
			case *IfStmt:
				g.generateIfStmtForSlice(n, sliceVar)
			case *GoCode:
				g.generateGoCode(n)
			case *GoExpr:
				elemVar := g.nextVar()
				g.writef("%s := element.New(element.WithText(%s))\n", elemVar, n.Code)
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
			}
		}
		g.indent--
		g.writeln("}")
	} else {
		g.writeln("}")
	}
}

// nextVar returns the next unique variable name.
func (g *Generator) nextVar() string {
	name := fmt.Sprintf("__tui_%d", g.varCounter)
	g.varCounter++
	return name
}

// write writes a string without indentation.
func (g *Generator) write(s string) {
	g.buf.WriteString(s)
}

// writef writes a formatted string with indentation.
func (g *Generator) writef(format string, args ...interface{}) {
	g.writeIndent()
	fmt.Fprintf(&g.buf, format, args...)
}

// writeln writes a line with indentation.
func (g *Generator) writeln(s string) {
	if s == "" {
		g.buf.WriteByte('\n')
		return
	}
	g.writeIndent()
	g.buf.WriteString(s)
	g.buf.WriteByte('\n')
}

// writeIndent writes the current indentation.
func (g *Generator) writeIndent() {
	for i := 0; i < g.indent; i++ {
		g.buf.WriteByte('\t')
	}
}

// GenerateString is a convenience method that returns the generated code as a string.
func (g *Generator) GenerateString(file *File, sourceFile string) (string, error) {
	data, err := g.Generate(file, sourceFile)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// ParseAndGenerate parses source code and generates Go code in one step.
// This is a convenience function for simple use cases.
func ParseAndGenerate(filename, source string) ([]byte, error) {
	lexer := NewLexer(filename, source)
	parser := NewParser(lexer)

	file, err := parser.ParseFile()
	if err != nil {
		return nil, err
	}

	gen := NewGenerator()
	return gen.Generate(file, filename)
}

// textElementWithOptions checks if this is a text element that needs options
// extracted from its children for WithText.
func textElementWithOptions(elem *Element) bool {
	if elem.Tag != "span" && elem.Tag != "p" {
		return false
	}
	// Has text content that should go into WithText
	for _, child := range elem.Children {
		switch child.(type) {
		case *TextContent, *GoExpr:
			return true
		}
	}
	return false
}

// skipTextChildren returns true if text element children should not be
// processed as AddChild calls (they're already in WithText).
func skipTextChildren(elem *Element) bool {
	if elem.Tag != "span" && elem.Tag != "p" {
		return false
	}
	// Only skip if there's a single text/expr child that was used for WithText
	if len(elem.Children) != 1 {
		return false
	}
	switch elem.Children[0].(type) {
	case *TextContent, *GoExpr:
		return true
	}
	return false
}

// GenerateToBuffer generates code and writes it to the buffer.
// This avoids an extra allocation compared to Generate().
func (g *Generator) GenerateToBuffer(buf *bytes.Buffer, file *File, sourceFile string) error {
	data, err := g.Generate(file, sourceFile)
	if err != nil {
		return err
	}
	buf.Write(data)
	return nil
}

// generateStateBindings generates Bind() calls for reactive state bindings.
// This is called after all elements are created so the element variables exist.
func (g *Generator) generateStateBindings() {
	if len(g.stateBindings) == 0 {
		return
	}

	g.writeln("")
	g.writeln("// State bindings")

	// Build a map of state variable names to their types
	stateTypes := make(map[string]string)
	for _, sv := range g.stateVars {
		stateTypes[sv.Name] = sv.Type
	}

	for _, binding := range g.stateBindings {
		g.generateBinding(binding, stateTypes)
	}
}

// generateBinding generates a Bind() call for a single state binding.
func (g *Generator) generateBinding(b StateBinding, stateTypes map[string]string) {
	if len(b.StateVars) == 0 {
		return
	}

	// Determine the setter method based on attribute
	setter := g.getSetterForAttribute(b.Attribute)
	if setter == "" {
		return
	}

	if len(b.StateVars) == 1 {
		// Single state variable - direct binding
		stateName := b.StateVars[0]
		stateType := stateTypes[stateName]
		g.writef("%s.Bind(func(_ %s) {\n", stateName, stateType)
		g.indent++
		g.writef("%s.%s(%s)\n", b.ElementName, setter, b.Expr)
		g.indent--
		g.writeln("})")
	} else {
		// Multiple state variables - shared update function
		updateFn := fmt.Sprintf("__update_%s", b.ElementName)
		g.writef("%s := func() { %s.%s(%s) }\n", updateFn, b.ElementName, setter, b.Expr)
		for _, stateName := range b.StateVars {
			stateType := stateTypes[stateName]
			g.writef("%s.Bind(func(_ %s) { %s() })\n", stateName, stateType, updateFn)
		}
	}
}

// getSetterForAttribute returns the element setter method for a given attribute.
func (g *Generator) getSetterForAttribute(attr string) string {
	switch attr {
	case "text":
		return "SetText"
	case "class":
		// Note: class attribute bindings would need SetClass or similar
		// For now, we don't support dynamic class bindings since element
		// doesn't have a SetClass method. This is a future enhancement.
		return ""
	default:
		return ""
	}
}
