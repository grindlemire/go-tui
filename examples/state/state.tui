// state.tui - Example demonstrating Refs, State, and Event Handling
//
// This example shows all three features working together:
// - Named refs (#Name) for imperative element access
// - State[T] for reactive value display
// - Event handlers for input, channels, and timers
// - No bool returns needed - mutations mark dirty automatically

package main

import (
    "fmt"
    "time"
)

@component StreamingCounter(dataCh chan string) {
    // State - reactive values that auto-update bound elements
    count := tui.NewState(0)
    lines := tui.NewState([]string{})
    elapsed := tui.NewState(0)

    <div class="flex-col gap-1 p-1 border-single">
        // Header with reactive count and elapsed time
        <div class="flex justify-between">
            <span class="font-bold">{"Streaming Counter"}</span>
            <span class="text-dim">
                {fmt.Sprintf("Count: %d | Time: %ds", count.Get(), elapsed.Get())}
            </span>
        </div>

        // Buttons with click handlers
        <div class="flex gap-2">
            <button onClick={increment(count)}>{"+ Increment"}</button>
            <button onClick={decrement(count)}>{"- Decrement"}</button>
            <button onClick={reset(count)}>{"Reset"}</button>
        </div>

        // Scrollable content area
        // - #Content ref for scroll operations
        // - tui.Watch() registers channel watcher
        // - tui.OnTimer() registers timer
        <div #Content
             class="flex-col border-cyan"
             scrollable={element.ScrollVertical}
             onChannel={tui.Watch(dataCh, handleData(lines))}
             onTimer={tui.OnTimer(time.Second, tick(elapsed))}
             onKeyPress={handleKeys(view)}
             focusable={true}
             flexGrow={1}>
            @for _, line := range lines.Get() {
                <span>{line}</span>
            }
        </div>

        // Footer with line count
        <div class="border-single" height={1}>
            <span class="text-dim">
                {fmt.Sprintf("Lines: %d | j/k scroll, G bottom, g top, q quit", len(lines.Get()))}
            </span>
        </div>
    </div>
}

// Click handlers - no bool return needed, Set() marks dirty automatically
func increment(count *tui.State[int]) func() {
    return func() {
        count.Set(count.Get() + 1)
    }
}

func decrement(count *tui.State[int]) func() {
    return func() {
        count.Set(count.Get() - 1)
    }
}

func reset(count *tui.State[int]) func() {
    return func() {
        count.Set(0)
    }
}

// Channel handler - called when data arrives on channel
func handleData(lines *tui.State[[]string]) func(string) {
    return func(line string) {
        lines.Set(append(lines.Get(), line))
    }
}

// Key handler - uses ref for scroll operations
func handleKeys(v StreamingCounterView) func(tui.KeyEvent) {
    return func(e tui.KeyEvent) {
        switch e.Rune {
        case 'j':
            v.Content.ScrollBy(0, 1)
        case 'k':
            v.Content.ScrollBy(0, -1)
        case 'G':
            v.Content.ScrollToBottom()
        case 'g':
            v.Content.ScrollTo(0, 0)
        case 'q':
            tui.Stop()
        }
    }
}

// Timer handler - called every second
func tick(elapsed *tui.State[int]) func() {
    return func() {
        elapsed.Set(elapsed.Get() + 1)
    }
}
