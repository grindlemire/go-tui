package tuigen

import (
	"bytes"
	"fmt"
	"go/format"

	"golang.org/x/tools/imports"
)

// deferredWatcher tracks a watcher to be attached after all elements are created.
type deferredWatcher struct {
	elementVar  string // The element variable to attach the watcher to
	watcherExpr string // The watcher expression (e.g., "tui.Watch(dataCh, handler)")
}

// deferredHandler tracks a handler to be set after all elements are created.
type deferredHandler struct {
	elementVar string // The element variable to set the handler on
	setter     string // The setter method (e.g., "SetOnKeyPress")
	handlerExp string // The handler expression
}

// Generator transforms a validated AST into Go source code.
type Generator struct {
	buf        bytes.Buffer
	indent     int
	varCounter int
	sourceFile string // original .tui filename for header comment

	// Named refs tracking for current component
	namedRefs []NamedRef

	// Watcher expressions for current component (onChannel/onTimer)
	watchers []string

	// Deferred watcher attachments (element var -> watcher expr)
	// These are emitted after all elements are created so refs are valid
	deferredWatchers []deferredWatcher

	// Deferred handler attachments (for onKeyPress, onClick that reference refs)
	deferredHandlers []deferredHandler

	// Component calls with watchers that need aggregation
	componentVars []string

	// State tracking for current component (for reactive bindings)
	stateVars     []StateVar
	stateBindings []StateBinding

	// SkipImports uses format.Source instead of imports.Process (faster for tests)
	SkipImports bool
}

// NewGenerator creates a new code generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate produces Go source code from a parsed and analyzed AST.
// Returns the generated code as a byte slice, or an error if generation fails.
func (g *Generator) Generate(file *File, sourceFile string) ([]byte, error) {
	g.buf.Reset()
	g.varCounter = 0
	g.sourceFile = sourceFile

	// Generate header
	g.generateHeader()

	// Generate package
	g.generatePackage(file.Package)

	// Generate imports
	g.generateImports(file.Imports)

	// Generate top-level Go declarations (type, const, var)
	for _, decl := range file.Decls {
		g.generateGoDecl(decl)
	}

	// Generate top-level Go functions
	for _, fn := range file.Funcs {
		g.generateGoFunc(fn)
	}

	// Generate components
	for _, comp := range file.Components {
		g.generateComponent(comp)
	}

	// For tests: just format without import processing (much faster)
	if g.SkipImports {
		return format.Source(g.buf.Bytes())
	}

	// For production: format and fix imports with goimports
	return imports.Process(g.sourceFile, g.buf.Bytes(), nil)
}

// generateHeader writes the "DO NOT EDIT" comment.
func (g *Generator) generateHeader() {
	g.writeln("// Code generated by tui generate. DO NOT EDIT.")
	if g.sourceFile != "" {
		g.writef("// Source: %s\n", g.sourceFile)
	}
	g.writeln("")
}

// generatePackage writes the package declaration.
func (g *Generator) generatePackage(pkg string) {
	g.writef("package %s\n\n", pkg)
}

// generateImports writes the import block.
func (g *Generator) generateImports(imports []Import) {
	if len(imports) == 0 {
		// Always include root tui import for generated code
		g.writeln("import (")
		g.indent++
		g.writeln(`tui "github.com/grindlemire/go-tui"`)
		g.indent--
		g.writeln(")")
		g.writeln("")
		return
	}

	// Check if root tui package is already imported
	hasTui := false
	for _, imp := range imports {
		if imp.Path == "github.com/grindlemire/go-tui" {
			hasTui = true
		}
	}

	g.writeln("import (")
	g.indent++

	for _, imp := range imports {
		if imp.Alias != "" {
			g.writef("%s %q\n", imp.Alias, imp.Path)
		} else {
			g.writef("%q\n", imp.Path)
		}
	}

	// Add required import if not present
	if !hasTui {
		g.writeln("")
		g.writeln(`tui "github.com/grindlemire/go-tui"`)
	}

	g.indent--
	g.writeln(")")
	g.writeln("")
}

// nextVar returns the next unique variable name.
func (g *Generator) nextVar() string {
	name := fmt.Sprintf("__tui_%d", g.varCounter)
	g.varCounter++
	return name
}

// write writes a string without indentation.
func (g *Generator) write(s string) {
	g.buf.WriteString(s)
}

// writef writes a formatted string with indentation.
func (g *Generator) writef(format string, args ...interface{}) {
	g.writeIndent()
	fmt.Fprintf(&g.buf, format, args...)
}

// writeln writes a line with indentation.
func (g *Generator) writeln(s string) {
	if s == "" {
		g.buf.WriteByte('\n')
		return
	}
	g.writeIndent()
	g.buf.WriteString(s)
	g.buf.WriteByte('\n')
}

// writeIndent writes the current indentation.
func (g *Generator) writeIndent() {
	for i := 0; i < g.indent; i++ {
		g.buf.WriteByte('\t')
	}
}

// GenerateString is a convenience method that returns the generated code as a string.
func (g *Generator) GenerateString(file *File, sourceFile string) (string, error) {
	data, err := g.Generate(file, sourceFile)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// ParseAndGenerate parses source code and generates Go code in one step.
// This is a convenience function for simple use cases.
func ParseAndGenerate(filename, source string) ([]byte, error) {
	return parseAndGenerate(filename, source, false)
}

// parseAndGenerateSkipImports is like ParseAndGenerate but uses format.Source
// instead of imports.Process. This is much faster for tests.
func parseAndGenerateSkipImports(filename, source string) ([]byte, error) {
	return parseAndGenerate(filename, source, true)
}

func parseAndGenerate(filename, source string, skipImports bool) ([]byte, error) {
	lexer := NewLexer(filename, source)
	parser := NewParser(lexer)

	file, err := parser.ParseFile()
	if err != nil {
		return nil, err
	}

	gen := NewGenerator()
	gen.SkipImports = skipImports
	return gen.Generate(file, filename)
}

// textElementWithOptions checks if this is a text element that needs options
// extracted from its children for WithText.
func textElementWithOptions(elem *Element) bool {
	if elem.Tag != "span" && elem.Tag != "p" {
		return false
	}
	// Has text content that should go into WithText
	for _, child := range elem.Children {
		switch child.(type) {
		case *TextContent, *GoExpr:
			return true
		}
	}
	return false
}

// skipTextChildren returns true if text element children should not be
// processed as AddChild calls (they're already in WithText).
func skipTextChildren(elem *Element) bool {
	if elem.Tag != "span" && elem.Tag != "p" {
		return false
	}
	// Only skip if there's a single text/expr child that was used for WithText
	if len(elem.Children) != 1 {
		return false
	}
	switch elem.Children[0].(type) {
	case *TextContent, *GoExpr:
		return true
	}
	return false
}

// GenerateToBuffer generates code and writes it to the buffer.
// This avoids an extra allocation compared to Generate().
func (g *Generator) GenerateToBuffer(buf *bytes.Buffer, file *File, sourceFile string) error {
	data, err := g.Generate(file, sourceFile)
	if err != nil {
		return err
	}
	buf.Write(data)
	return nil
}

// generateStateBindings generates Bind() calls for reactive state bindings.
// This is called after all elements are created so the element variables exist.
func (g *Generator) generateStateBindings() {
	if len(g.stateBindings) == 0 {
		return
	}

	g.writeln("")
	g.writeln("// State bindings")

	// Build a map of state variable names to their types
	stateTypes := make(map[string]string)
	for _, sv := range g.stateVars {
		stateTypes[sv.Name] = sv.Type
	}

	for _, binding := range g.stateBindings {
		g.generateBinding(binding, stateTypes)
	}
}

// generateBinding generates a Bind() call for a single state binding.
func (g *Generator) generateBinding(b StateBinding, stateTypes map[string]string) {
	if len(b.StateVars) == 0 {
		return
	}

	// Determine the setter method based on attribute
	setter := g.getSetterForAttribute(b.Attribute)
	if setter == "" {
		return
	}

	if len(b.StateVars) == 1 {
		// Single state variable - direct binding
		stateName := b.StateVars[0]
		stateType := stateTypes[stateName]
		g.writef("%s.Bind(func(_ %s) {\n", stateName, stateType)
		g.indent++
		g.writef("%s.%s(%s)\n", b.ElementName, setter, b.Expr)
		g.indent--
		g.writeln("})")
	} else {
		// Multiple state variables - shared update function
		updateFn := fmt.Sprintf("__update_%s", b.ElementName)
		g.writef("%s := func() { %s.%s(%s) }\n", updateFn, b.ElementName, setter, b.Expr)
		for _, stateName := range b.StateVars {
			stateType := stateTypes[stateName]
			g.writef("%s.Bind(func(_ %s) { %s() })\n", stateName, stateType, updateFn)
		}
	}
}

// getSetterForAttribute returns the element setter method for a given attribute.
func (g *Generator) getSetterForAttribute(attr string) string {
	switch attr {
	case "text":
		return "SetText"
	case "class":
		// Note: class attribute bindings would need SetClass or similar
		// For now, we don't support dynamic class bindings since element
		// doesn't have a SetClass method. This is a future enhancement.
		return ""
	default:
		return ""
	}
}
