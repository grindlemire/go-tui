package tuigen

import (
	"bytes"
	"fmt"
	"go/format"
	"strconv"

	"golang.org/x/tools/imports"
)

// deferredWatcher tracks a watcher to be attached after all elements are created.
type deferredWatcher struct {
	elementVar  string // The element variable to attach the watcher to
	watcherExpr string // The watcher expression (e.g., "tui.Watch(dataCh, handler)")
}

// deferredHandler tracks a handler to be set after all elements are created.
type deferredHandler struct {
	elementVar string // The element variable to set the handler on
	setter     string // The setter method (e.g., "SetOnKeyPress")
	handlerExp string // The handler expression
}

// Generator transforms a validated AST into Go source code.
type Generator struct {
	buf        bytes.Buffer
	indent     int
	varCounter int
	sourceFile string // original .tui filename for header comment

	// Named refs tracking for current component
	namedRefs []NamedRef

	// Watcher expressions for current component (onChannel/onTimer)
	watchers []string

	// Deferred watcher attachments (element var -> watcher expr)
	// These are emitted after all elements are created so refs are valid
	deferredWatchers []deferredWatcher

	// Deferred handler attachments (for onKeyPress, onClick that reference refs)
	deferredHandlers []deferredHandler

	// Component calls with watchers that need aggregation
	componentVars []string

	// State tracking for current component (for reactive bindings)
	stateVars     []StateVar
	stateBindings []StateBinding

	// SkipImports uses format.Source instead of imports.Process (faster for tests)
	SkipImports bool
}

// NewGenerator creates a new code generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate produces Go source code from a parsed and analyzed AST.
// Returns the generated code as a byte slice, or an error if generation fails.
func (g *Generator) Generate(file *File, sourceFile string) ([]byte, error) {
	g.buf.Reset()
	g.varCounter = 0
	g.sourceFile = sourceFile

	// Generate header
	g.generateHeader()

	// Generate package
	g.generatePackage(file.Package)

	// Generate imports
	g.generateImports(file.Imports)

	// Generate top-level Go declarations (type, const, var)
	for _, decl := range file.Decls {
		g.generateGoDecl(decl)
	}

	// Generate top-level Go functions
	for _, fn := range file.Funcs {
		g.generateGoFunc(fn)
	}

	// Generate components
	for _, comp := range file.Components {
		g.generateComponent(comp)
	}

	// For tests: just format without import processing (much faster)
	if g.SkipImports {
		return format.Source(g.buf.Bytes())
	}

	// For production: format and fix imports with goimports
	return imports.Process(g.sourceFile, g.buf.Bytes(), nil)
}

// generateHeader writes the "DO NOT EDIT" comment.
func (g *Generator) generateHeader() {
	g.writeln("// Code generated by tui generate. DO NOT EDIT.")
	if g.sourceFile != "" {
		g.writef("// Source: %s\n", g.sourceFile)
	}
	g.writeln("")
}

// generatePackage writes the package declaration.
func (g *Generator) generatePackage(pkg string) {
	g.writef("package %s\n\n", pkg)
}

// generateImports writes the import block.
func (g *Generator) generateImports(imports []Import) {
	if len(imports) == 0 {
		// Always include root tui import for generated code
		g.writeln("import (")
		g.indent++
		g.writeln(`tui "github.com/grindlemire/go-tui"`)
		g.indent--
		g.writeln(")")
		g.writeln("")
		return
	}

	// Check if root tui package is already imported
	hasTui := false
	for _, imp := range imports {
		if imp.Path == "github.com/grindlemire/go-tui" {
			hasTui = true
		}
	}

	g.writeln("import (")
	g.indent++

	for _, imp := range imports {
		if imp.Alias != "" {
			g.writef("%s %q\n", imp.Alias, imp.Path)
		} else {
			g.writef("%q\n", imp.Path)
		}
	}

	// Add required import if not present
	if !hasTui {
		g.writeln("")
		g.writeln(`tui "github.com/grindlemire/go-tui"`)
	}

	g.indent--
	g.writeln(")")
	g.writeln("")
}

// generateComponent generates a Go function from a component.
func (g *Generator) generateComponent(comp *Component) {
	// Reset variable counter and watcher tracking for each component
	g.varCounter = 0
	g.watchers = nil
	g.deferredWatchers = nil
	g.deferredHandlers = nil
	g.componentVars = nil
	g.stateVars = nil
	g.stateBindings = nil

	// Collect named refs from this component
	analyzer := NewAnalyzer()
	g.namedRefs = analyzer.CollectNamedRefs(comp)

	// Detect state variables and bindings
	g.stateVars = analyzer.DetectStateVars(comp)
	g.stateBindings = analyzer.DetectStateBindings(comp, g.stateVars)

	// Generate view struct for this component (always generated)
	structName := comp.Name + "View"
	g.generateViewStruct(comp.Name, g.namedRefs)

	// Generate function signature - always returns struct
	g.writef("func %s(", comp.Name)
	for i, param := range comp.Params {
		if i > 0 {
			g.write(", ")
		}
		g.writef("%s %s", param.Name, param.Type)
	}
	// Add children parameter if component accepts children
	if comp.AcceptsChildren {
		if len(comp.Params) > 0 {
			g.write(", ")
		}
		g.write("children []*tui.Element")
	}
	g.writef(") %s {\n", structName)
	g.indent++

	// Pre-declare view variable so closures can capture it
	g.writef("var view %s\n", structName)
	g.writeln("var watchers []tui.Watcher")
	g.writeln("")

	// Forward-declare ALL named refs at function scope
	// This allows handlers to reference refs that appear later in the tree
	for _, ref := range g.namedRefs {
		if ref.InLoop {
			if ref.KeyExpr != "" {
				g.writef("%s := make(map[%s]*tui.Element)\n", ref.Name, ref.KeyType)
			} else {
				g.writef("var %s []*tui.Element\n", ref.Name)
			}
		} else {
			// ALL non-loop refs are forward-declared as pointers
			g.writef("var %s *tui.Element\n", ref.Name)
		}
	}

	// Add blank line after declarations if we had any
	if len(g.namedRefs) > 0 {
		g.writeln("")
	}

	// Track the root element variable name
	// The root is the first top-level Element (not LetBinding, which is typically a child reference)
	var rootVar string
	var rootRef string       // Named ref on root element, if any
	var rootIsComponent bool // Whether root is a component call (needs .Root accessor)

	// Generate body nodes
	for _, node := range comp.Body {
		switch n := node.(type) {
		case *Element:
			varName := g.generateElementWithRefs(n, "", false, false)
			if rootVar == "" {
				rootVar = varName
				if n.NamedRef != "" {
					rootRef = n.NamedRef
				}
			}
		case *LetBinding:
			// @let bindings create elements that are typically used as children
			// They are NOT the root element unless explicitly used
			g.generateLetBinding(n, "")
		case *ForLoop:
			g.generateForLoopWithRefs(n, "", false)
		case *IfStmt:
			g.generateIfStmtWithRefs(n, "", false)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			// A bare expression in component body - treat as statement
			g.writef("%s\n", n.Code)
		case *ComponentCall:
			varName := g.generateComponentCallWithRefs(n, "")
			if rootVar == "" {
				rootVar = varName
				rootIsComponent = true
			}
		}
	}

	// Emit watcher collection statements (collected during element generation)
	if len(g.watchers) > 0 || len(g.componentVars) > 0 {
		g.writeln("")
		// Append watchers from onChannel/onTimer attributes
		for _, watcher := range g.watchers {
			g.writef("watchers = append(watchers, %s)\n", watcher)
		}
		// Aggregate watchers from child component calls
		for _, compVar := range g.componentVars {
			g.writef("watchers = append(watchers, %s.GetWatchers()...)\n", compVar)
		}
	}

	// Emit deferred handler attachments (after all elements/refs are created)
	if len(g.deferredHandlers) > 0 {
		g.writeln("")
		g.writeln("// Attach handlers (deferred until refs are assigned)")
		for _, dh := range g.deferredHandlers {
			g.writef("%s.%s(%s)\n", dh.elementVar, dh.setter, dh.handlerExp)
		}
	}

	// Emit deferred watcher attachments (after all elements/refs are created)
	if len(g.deferredWatchers) > 0 {
		g.writeln("")
		g.writeln("// Attach watchers (deferred until refs are assigned)")
		for _, dw := range g.deferredWatchers {
			g.writef("%s.AddWatcher(%s)\n", dw.elementVar, dw.watcherExpr)
		}
	}

	// Generate state bindings (reactive updates)
	g.generateStateBindings()

	// Populate view struct before returning
	g.writeln("")
	g.writef("view = %s{\n", structName)
	g.indent++
	if rootVar != "" {
		if rootIsComponent {
			g.writef("Root: %s.Root,\n", rootVar)
		} else {
			g.writef("Root: %s,\n", rootVar)
		}
	} else {
		g.writeln("Root: nil,")
	}
	g.writeln("watchers: watchers,")
	for _, ref := range g.namedRefs {
		// If this ref is on the root element, point to rootVar
		if ref.Name == rootRef {
			g.writef("%s: %s,\n", ref.Name, rootVar)
		} else {
			g.writef("%s: %s,\n", ref.Name, ref.Name)
		}
	}
	g.indent--
	g.writeln("}")

	g.writeln("return view")

	g.indent--
	g.writeln("}")
	g.writeln("")
}

// generateViewStruct generates the ComponentNameView struct definition.
func (g *Generator) generateViewStruct(compName string, refs []NamedRef) {
	structName := compName + "View"

	g.writef("type %s struct {\n", structName)
	g.indent++
	g.writeln("Root     *tui.Element")
	g.writeln("watchers []tui.Watcher")

	for _, ref := range refs {
		if ref.InLoop {
			if ref.KeyExpr != "" {
				// Map type for keyed refs
				g.writef("%s map[%s]*tui.Element\n", ref.Name, ref.KeyType)
			} else {
				// Slice type for unkeyed loop refs
				g.writef("%s []*tui.Element\n", ref.Name)
			}
		} else if ref.InConditional {
			g.writef("%s *tui.Element // may be nil\n", ref.Name)
		} else {
			g.writef("%s *tui.Element\n", ref.Name)
		}
	}

	g.indent--
	g.writeln("}")
	g.writeln("")

	// Generate GetRoot() method to implement tui.Viewable
	g.writef("func (v %s) GetRoot() tui.Renderable { return v.Root }\n", structName)
	g.writeln("")

	// Generate GetWatchers() method to implement tui.Viewable
	g.writef("func (v %s) GetWatchers() []tui.Watcher { return v.watchers }\n", structName)
	g.writeln("")
}

// generateElement generates code for an element and returns the variable name.
// If parentVar is non-empty, adds this element as a child.
func (g *Generator) generateElement(elem *Element, parentVar string) string {
	return g.generateElementWithRefs(elem, parentVar, false, false)
}

// generateElementWithRefs generates code for an element with named ref handling.
// inLoop and inConditional track the context for proper variable handling.
func (g *Generator) generateElementWithRefs(elem *Element, parentVar string, inLoop bool, inConditional bool) string {
	// Determine variable name and whether we need := or =
	var varName string
	useAssignment := false // true means use "=", false means use ":="

	if elem.NamedRef != "" {
		if inLoop {
			// In loops, use temp var then append/assign to the ref slice/map
			varName = g.nextVar()
		} else {
			// Outside loops, the ref is forward-declared, use assignment
			varName = elem.NamedRef
			useAssignment = true
		}
	} else {
		varName = g.nextVar()
	}

	// Build options from attributes and tag
	elemOpts := g.buildElementOptions(elem)

	// Generate element creation - use = for forward-declared refs, := otherwise
	assignOp := ":="
	if useAssignment {
		assignOp = "="
	}

	if len(elemOpts.options) == 0 {
		g.writef("%s %s tui.New()\n", varName, assignOp)
	} else {
		g.writef("%s %s tui.New(\n", varName, assignOp)
		g.indent++
		for _, opt := range elemOpts.options {
			g.writef("%s,\n", opt)
		}
		g.indent--
		g.writeln(")")
	}

	// Defer watcher attachment until after all elements are created
	// This ensures forward-declared refs are assigned before handlers reference them
	for _, watcher := range elemOpts.watchers {
		g.deferredWatchers = append(g.deferredWatchers, deferredWatcher{
			elementVar:  varName,
			watcherExpr: watcher,
		})
	}

	// Defer handler attachment (onKeyPress, onClick) for the same reason
	for _, h := range elemOpts.handlers {
		g.deferredHandlers = append(g.deferredHandlers, deferredHandler{
			elementVar: varName,
			setter:     h.setter,
			handlerExp: h.expr,
		})
	}

	// Handle named ref assignment in loops (append to slice or assign to map)
	if elem.NamedRef != "" && inLoop {
		if elem.RefKey != nil {
			// Map-based ref: assign to map with key
			g.writef("%s[%s] = %s\n", elem.NamedRef, elem.RefKey.Code, varName)
		} else {
			// Slice-based ref: append to slice
			g.writef("%s = append(%s, %s)\n", elem.NamedRef, elem.NamedRef, varName)
		}
	}

	// Generate children - skip if text element already has content in WithText
	if !skipTextChildren(elem) {
		g.generateChildrenWithRefs(varName, elem.Children, inLoop, inConditional)
	}

	// Add to parent if specified
	if parentVar != "" {
		g.writef("%s.AddChild(%s)\n", parentVar, varName)
	}

	return varName
}

// elementOptions holds options, watchers, and deferred handlers for an element.
type elementOptions struct {
	options  []string
	watchers []string
	handlers []struct { // Handlers to defer (onKeyPress, onClick)
		setter string // e.g., "SetOnKeyPress"
		expr   string // the handler expression
	}
}

// buildElementOptions generates option expressions for an element.
// Returns both element options and any watcher expressions found.
func (g *Generator) buildElementOptions(elem *Element) elementOptions {
	var result elementOptions

	// Handle tag-specific options
	switch elem.Tag {
	case "hr":
		result.options = append(result.options, "tui.WithHR()")
	case "br":
		result.options = append(result.options, "tui.WithWidth(0)")
		result.options = append(result.options, "tui.WithHeight(1)")
	case "span", "p":
		// If text element has children that are text content, add WithText
		textContent := g.extractTextContent(elem.Children)
		if textContent != "" {
			result.options = append(result.options, fmt.Sprintf("tui.WithText(%s)", textContent))
		}
	}

	// Track text style methods from class attribute separately
	var classTextMethods []string

	// Generate options from attributes
	for _, attr := range elem.Attributes {
		// Handle class attribute specially - parse Tailwind classes
		if attr.Name == "class" {
			classValue := g.getClassAttributeValue(attr)
			if classValue != "" {
				twResult := ParseTailwindClasses(classValue)
				// Add direct options
				result.options = append(result.options, twResult.Options...)
				// Collect text style methods for combining later
				classTextMethods = append(classTextMethods, twResult.TextMethods...)
			}
			continue
		}

		// Handle watcher attributes (onChannel, onTimer) - they create watchers, not element options
		if watcherAttributes[attr.Name] {
			watcherExpr := g.generateAttributeValue(attr.Value)
			if watcherExpr != "" {
				result.watchers = append(result.watchers, watcherExpr)
			}
			continue
		}

		// Handle handler attributes - defer them so forward-declared refs are assigned first
		if setter, isHandler := handlerAttributes[attr.Name]; isHandler {
			handlerExpr := g.generateAttributeValue(attr.Value)
			if handlerExpr != "" {
				result.handlers = append(result.handlers, struct {
					setter string
					expr   string
				}{setter: setter, expr: handlerExpr})
			}
			continue
		}

		opt := g.generateAttributeOption(attr)
		if opt != "" {
			result.options = append(result.options, opt)
		}
	}

	// Build combined text style from class attribute if any
	if len(classTextMethods) > 0 {
		textStyleOpt := BuildTextStyleOption(classTextMethods)
		if textStyleOpt != "" {
			result.options = append(result.options, textStyleOpt)
		}
	}

	return result
}

// getClassAttributeValue extracts the string value from a class attribute.
func (g *Generator) getClassAttributeValue(attr *Attribute) string {
	switch v := attr.Value.(type) {
	case *StringLit:
		return v.Value
	default:
		// class attribute only supports string literals for now
		return ""
	}
}

// extractTextContent extracts text from element children for WithText.
// Returns empty string if children contain non-text content.
func (g *Generator) extractTextContent(children []Node) string {
	if len(children) == 0 {
		return ""
	}

	// If single GoExpr child, return the expression
	if len(children) == 1 {
		if expr, ok := children[0].(*GoExpr); ok {
			return expr.Code
		}
		if text, ok := children[0].(*TextContent); ok {
			return strconv.Quote(text.Text)
		}
	}

	// Multiple children or complex content - handled separately in generateChildren
	return ""
}

// handlerAttributes maps handler/callback attribute names to their setter methods.
// These attributes take function values that might capture forward-declared refs,
// so they are always deferred until after all elements are created.
// When adding a new handler attribute, add it here AND add the Set* method to element.go.
var handlerAttributes = map[string]string{
	"onKeyPress": "SetOnKeyPress",
	"onClick":    "SetOnClick",
	"onEvent":    "SetOnEvent",
	"onFocus":    "SetOnFocus",
	"onBlur":     "SetOnBlur",
}

// watcherAttributes are special attributes that create watchers, not element options.
// They are deferred and attached via AddWatcher after all elements are created.
var watcherAttributes = map[string]bool{
	"onChannel": true,
	"onTimer":   true,
}

// attributeToOption maps DSL attribute names to tui.With* functions.
// NOTE: Handler attributes (onKeyPress, onClick, etc.) are NOT in this map -
// they are in handlerAttributes and are deferred so refs are assigned first.
var attributeToOption = map[string]string{
	// Dimensions
	"width":         "tui.WithWidth(%s)",
	"widthPercent":  "tui.WithWidthPercent(%s)",
	"height":        "tui.WithHeight(%s)",
	"heightPercent": "tui.WithHeightPercent(%s)",
	"minWidth":      "tui.WithMinWidth(%s)",
	"minHeight":     "tui.WithMinHeight(%s)",
	"maxWidth":      "tui.WithMaxWidth(%s)",
	"maxHeight":     "tui.WithMaxHeight(%s)",

	// Flex container
	"direction": "tui.WithDirection(%s)",
	"justify":   "tui.WithJustify(%s)",
	"align":     "tui.WithAlign(%s)",
	"gap":       "tui.WithGap(%s)",

	// Flex item
	"flexGrow":   "tui.WithFlexGrow(%s)",
	"flexShrink": "tui.WithFlexShrink(%s)",
	"alignSelf":  "tui.WithAlignSelf(%s)",

	// Spacing
	"padding": "tui.WithPadding(%s)",
	"margin":  "tui.WithMargin(%s)",

	// Visual
	"border":      "tui.WithBorder(%s)",
	"borderStyle": "tui.WithBorderStyle(%s)",
	"background":  "tui.WithBackground(%s)",

	// Text
	"text":      "tui.WithText(%s)",
	"textStyle": "tui.WithTextStyle(%s)",
	"textAlign": "tui.WithTextAlign(%s)",

	// Focus (non-handler attributes only)
	"focusable": "tui.WithFocusable(%s)",

	// Scroll
	"scrollable": "tui.WithScrollable(%s)",
}

// generateAttributeOption generates an option expression from an attribute.
func (g *Generator) generateAttributeOption(attr *Attribute) string {
	template, ok := attributeToOption[attr.Name]
	if !ok {
		// Unknown attribute - skip with no error (analyzer should catch this)
		return ""
	}

	value := g.generateAttributeValue(attr.Value)
	return fmt.Sprintf(template, value)
}

// generateAttributeValue generates a Go expression from an attribute value.
func (g *Generator) generateAttributeValue(value Node) string {
	switch v := value.(type) {
	case *StringLit:
		return strconv.Quote(v.Value)
	case *IntLit:
		return strconv.FormatInt(v.Value, 10)
	case *FloatLit:
		return strconv.FormatFloat(v.Value, 'f', -1, 64)
	case *BoolLit:
		if v.Value {
			return "true"
		}
		return "false"
	case *GoExpr:
		return v.Code
	case *RawGoExpr:
		return v.Code
	default:
		return ""
	}
}

// generateChildren generates code for element children.
func (g *Generator) generateChildren(parentVar string, children []Node) {
	g.generateChildrenWithRefs(parentVar, children, false, false)
}

// generateChildrenWithRefs generates code for element children with ref context tracking.
func (g *Generator) generateChildrenWithRefs(parentVar string, children []Node, inLoop bool, inConditional bool) {
	for _, child := range children {
		switch c := child.(type) {
		case *Element:
			g.generateElementWithRefs(c, parentVar, inLoop, inConditional)
		case *LetBinding:
			g.generateLetBinding(c, parentVar)
		case *ForLoop:
			g.generateForLoopWithRefs(c, parentVar, inConditional)
		case *IfStmt:
			g.generateIfStmtWithRefs(c, parentVar, inLoop)
		case *GoExpr:
			// GoExpr as child - create text element with the expression
			varName := g.nextVar()
			g.writef("%s := tui.New(tui.WithText(%s))\n", varName, c.Code)
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		case *TextContent:
			// TextContent as child - create text element
			varName := g.nextVar()
			g.writef("%s := tui.New(tui.WithText(%s))\n", varName, strconv.Quote(c.Text))
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		case *RawGoExpr:
			// RawGoExpr is a variable reference - add directly
			g.writef("%s.AddChild(%s)\n", parentVar, c.Code)
		case *ComponentCall:
			g.generateComponentCallWithRefs(c, parentVar)
		case *ChildrenSlot:
			// Expand the children parameter
			g.writeln("for _, __child := range children {")
			g.indent++
			g.writef("%s.AddChild(__child)\n", parentVar)
			g.indent--
			g.writeln("}")
		}
	}
}

// generateLetBinding generates code for a @let binding.
func (g *Generator) generateLetBinding(let *LetBinding, parentVar string) {
	// Generate the element with a specific variable name
	elemOpts := g.buildElementOptions(let.Element)

	if len(elemOpts.options) == 0 {
		g.writef("%s := tui.New()\n", let.Name)
	} else {
		g.writef("%s := tui.New(\n", let.Name)
		g.indent++
		for _, opt := range elemOpts.options {
			g.writef("%s,\n", opt)
		}
		g.indent--
		g.writeln(")")
	}

	// Defer watcher attachment until after all elements are created
	for _, watcher := range elemOpts.watchers {
		g.deferredWatchers = append(g.deferredWatchers, deferredWatcher{
			elementVar:  let.Name,
			watcherExpr: watcher,
		})
	}

	// Defer handler attachment (onKeyPress, onClick)
	for _, h := range elemOpts.handlers {
		g.deferredHandlers = append(g.deferredHandlers, deferredHandler{
			elementVar: let.Name,
			setter:     h.setter,
			handlerExp: h.expr,
		})
	}

	// Generate children for the let-bound element - skip if text element already has content in WithText
	if !skipTextChildren(let.Element) {
		g.generateChildren(let.Name, let.Element.Children)
	}

	// Add to parent if specified
	if parentVar != "" {
		g.writef("%s.AddChild(%s)\n", parentVar, let.Name)
	}
}

// generateForLoop generates code for a @for loop.
func (g *Generator) generateForLoop(loop *ForLoop, parentVar string) {
	g.generateForLoopWithRefs(loop, parentVar, false)
}

// generateForLoopWithRefs generates code for a @for loop with ref context tracking.
func (g *Generator) generateForLoopWithRefs(loop *ForLoop, parentVar string, inConditional bool) {
	// Build loop header
	var loopVars string
	if loop.Index != "" {
		loopVars = fmt.Sprintf("%s, %s", loop.Index, loop.Value)
	} else {
		loopVars = loop.Value
	}

	g.writef("for %s := range %s {\n", loopVars, loop.Iterable)
	g.indent++

	// Silence unused variable warnings if index is not used
	if loop.Index != "" && loop.Index != "_" {
		g.writef("_ = %s\n", loop.Index)
	}

	// Generate loop body - now inside a loop context
	for _, node := range loop.Body {
		switch n := node.(type) {
		case *Element:
			g.generateElementWithRefs(n, parentVar, true, inConditional)
		case *LetBinding:
			g.generateLetBinding(n, parentVar)
		case *ForLoop:
			g.generateForLoopWithRefs(n, parentVar, inConditional)
		case *IfStmt:
			g.generateIfStmtWithRefs(n, parentVar, true) // now in loop context
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			// Bare expression in loop body
			if parentVar != "" {
				varName := g.nextVar()
				g.writef("%s := tui.New(tui.WithText(%s))\n", varName, n.Code)
				g.writef("%s.AddChild(%s)\n", parentVar, varName)
			} else {
				g.writef("%s\n", n.Code)
			}
		case *ComponentCall:
			g.generateComponentCallWithRefs(n, parentVar)
		case *ChildrenSlot:
			if parentVar != "" {
				g.writeln("for _, __child := range children {")
				g.indent++
				g.writef("%s.AddChild(__child)\n", parentVar)
				g.indent--
				g.writeln("}")
			}
		}
	}

	g.indent--
	g.writeln("}")
}

// generateIfStmt generates code for an @if statement.
func (g *Generator) generateIfStmt(stmt *IfStmt, parentVar string) {
	g.generateIfStmtWithRefs(stmt, parentVar, false)
}

// generateIfStmtWithRefs generates code for an @if statement with ref context tracking.
func (g *Generator) generateIfStmtWithRefs(stmt *IfStmt, parentVar string, inLoop bool) {
	g.writef("if %s {\n", stmt.Condition)
	g.indent++

	// Generate then body - now inside conditional context
	for _, node := range stmt.Then {
		g.generateBodyNodeWithRefs(node, parentVar, inLoop, true)
	}

	g.indent--

	// Generate else branch if present
	if len(stmt.Else) > 0 {
		g.write("} else ")

		// Check if else contains a single IfStmt (else-if chain)
		if len(stmt.Else) == 1 {
			if elseIf, ok := stmt.Else[0].(*IfStmt); ok {
				g.generateIfStmtWithRefs(elseIf, parentVar, inLoop)
				return
			}
		}

		g.writeln("{")
		g.indent++
		for _, node := range stmt.Else {
			g.generateBodyNodeWithRefs(node, parentVar, inLoop, true)
		}
		g.indent--
		g.writeln("}")
	} else {
		g.writeln("}")
	}
}

// generateBodyNode generates code for a node in a component/control flow body.
func (g *Generator) generateBodyNode(node Node, parentVar string) {
	g.generateBodyNodeWithRefs(node, parentVar, false, false)
}

// generateBodyNodeWithRefs generates code for a node with ref context tracking.
func (g *Generator) generateBodyNodeWithRefs(node Node, parentVar string, inLoop bool, inConditional bool) {
	switch n := node.(type) {
	case *Element:
		g.generateElementWithRefs(n, parentVar, inLoop, inConditional)
	case *LetBinding:
		g.generateLetBinding(n, parentVar)
	case *ForLoop:
		g.generateForLoopWithRefs(n, parentVar, inConditional)
	case *IfStmt:
		g.generateIfStmtWithRefs(n, parentVar, inLoop)
	case *GoCode:
		g.generateGoCode(n)
	case *GoExpr:
		if parentVar != "" {
			varName := g.nextVar()
			g.writef("%s := tui.New(tui.WithText(%s))\n", varName, n.Code)
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		} else {
			g.writef("%s\n", n.Code)
		}
	case *TextContent:
		if parentVar != "" {
			varName := g.nextVar()
			g.writef("%s := tui.New(tui.WithText(%s))\n", varName, strconv.Quote(n.Text))
			g.writef("%s.AddChild(%s)\n", parentVar, varName)
		}
	case *RawGoExpr:
		if parentVar != "" {
			g.writef("%s.AddChild(%s)\n", parentVar, n.Code)
		}
	case *ComponentCall:
		g.generateComponentCallWithRefs(n, parentVar)
	case *ChildrenSlot:
		if parentVar != "" {
			g.writeln("for _, __child := range children {")
			g.indent++
			g.writef("%s.AddChild(__child)\n", parentVar)
			g.indent--
			g.writeln("}")
		}
	}
}

// generateGoCode generates a raw Go statement.
func (g *Generator) generateGoCode(gc *GoCode) {
	g.writef("%s\n", gc.Code)
}

// generateGoFunc generates a top-level Go function.
func (g *Generator) generateGoFunc(fn *GoFunc) {
	g.writef("%s\n\n", fn.Code)
}

// generateGoDecl generates a top-level Go declaration (type, const, var).
func (g *Generator) generateGoDecl(decl *GoDecl) {
	g.writef("%s\n\n", decl.Code)
}

// generateComponentCall generates code for a component call.
// Returns the variable name holding the result.
func (g *Generator) generateComponentCall(call *ComponentCall, parentVar string) string {
	return g.generateComponentCallWithRefs(call, parentVar)
}

// generateComponentCallWithRefs generates code for a component call.
// Returns the variable name holding the result.
func (g *Generator) generateComponentCallWithRefs(call *ComponentCall, parentVar string) string {
	varName := g.nextVar()

	if len(call.Children) == 0 {
		// No children - simple call, returns view struct
		if call.Args == "" {
			g.writef("%s := %s()\n", varName, call.Name)
		} else {
			g.writef("%s := %s(%s)\n", varName, call.Name, call.Args)
		}
	} else {
		// Has children - build children slice first
		childrenVar := g.nextVar() + "_children"
		g.writef("%s := []*tui.Element{}\n", childrenVar)

		// Generate each child and append to slice
		for _, child := range call.Children {
			switch c := child.(type) {
			case *Element:
				elemVar := g.generateElement(c, "")
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *ComponentCall:
				innerVar := g.generateComponentCallWithRefs(c, "")
				g.writef("%s = append(%s, %s.Root)\n", childrenVar, childrenVar, innerVar)
			case *LetBinding:
				g.generateLetBinding(c, "")
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, c.Name)
			case *ForLoop:
				// For loops generate multiple elements - use a temp slice
				g.generateForLoopForSlice(c, childrenVar)
			case *IfStmt:
				// If statements may or may not generate elements
				g.generateIfStmtForSlice(c, childrenVar)
			case *GoExpr:
				// Expression - wrap in text element
				elemVar := g.nextVar()
				g.writef("%s := tui.New(tui.WithText(%s))\n", elemVar, c.Code)
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *TextContent:
				elemVar := g.nextVar()
				g.writef("%s := tui.New(tui.WithText(%s))\n", elemVar, strconv.Quote(c.Text))
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, elemVar)
			case *RawGoExpr:
				g.writef("%s = append(%s, %s)\n", childrenVar, childrenVar, c.Code)
			}
		}

		// Call component with children
		if call.Args == "" {
			g.writef("%s := %s(%s)\n", varName, call.Name, childrenVar)
		} else {
			g.writef("%s := %s(%s, %s)\n", varName, call.Name, call.Args, childrenVar)
		}
	}

	// Track this component call for watcher aggregation
	g.componentVars = append(g.componentVars, varName)

	// Add to parent if specified - use .Root to get the element from the view struct
	if parentVar != "" {
		g.writef("%s.AddChild(%s.Root)\n", parentVar, varName)
	}

	return varName
}

// generateForLoopForSlice generates a for loop that appends elements to a slice.
func (g *Generator) generateForLoopForSlice(loop *ForLoop, sliceVar string) {
	var loopVars string
	if loop.Index != "" {
		loopVars = fmt.Sprintf("%s, %s", loop.Index, loop.Value)
	} else {
		loopVars = loop.Value
	}

	g.writef("for %s := range %s {\n", loopVars, loop.Iterable)
	g.indent++

	if loop.Index != "" && loop.Index != "_" {
		g.writef("_ = %s\n", loop.Index)
	}

	for _, node := range loop.Body {
		switch n := node.(type) {
		case *Element:
			elemVar := g.generateElement(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		case *ComponentCall:
			callVar := g.generateComponentCallWithRefs(n, "")
			g.writef("%s = append(%s, %s.Root)\n", sliceVar, sliceVar, callVar)
		case *LetBinding:
			g.generateLetBinding(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
		case *ForLoop:
			g.generateForLoopForSlice(n, sliceVar)
		case *IfStmt:
			g.generateIfStmtForSlice(n, sliceVar)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			elemVar := g.nextVar()
			g.writef("%s := tui.New(tui.WithText(%s))\n", elemVar, n.Code)
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		}
	}

	g.indent--
	g.writeln("}")
}

// generateIfStmtForSlice generates an if statement that appends elements to a slice.
func (g *Generator) generateIfStmtForSlice(stmt *IfStmt, sliceVar string) {
	g.writef("if %s {\n", stmt.Condition)
	g.indent++

	for _, node := range stmt.Then {
		switch n := node.(type) {
		case *Element:
			elemVar := g.generateElement(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		case *ComponentCall:
			callVar := g.generateComponentCallWithRefs(n, "")
			g.writef("%s = append(%s, %s.Root)\n", sliceVar, sliceVar, callVar)
		case *LetBinding:
			g.generateLetBinding(n, "")
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
		case *ForLoop:
			g.generateForLoopForSlice(n, sliceVar)
		case *IfStmt:
			g.generateIfStmtForSlice(n, sliceVar)
		case *GoCode:
			g.generateGoCode(n)
		case *GoExpr:
			elemVar := g.nextVar()
			g.writef("%s := tui.New(tui.WithText(%s))\n", elemVar, n.Code)
			g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
		}
	}

	g.indent--

	if len(stmt.Else) > 0 {
		g.write("} else ")

		if len(stmt.Else) == 1 {
			if elseIf, ok := stmt.Else[0].(*IfStmt); ok {
				g.generateIfStmtForSlice(elseIf, sliceVar)
				return
			}
		}

		g.writeln("{")
		g.indent++
		for _, node := range stmt.Else {
			switch n := node.(type) {
			case *Element:
				elemVar := g.generateElement(n, "")
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
			case *ComponentCall:
				callVar := g.generateComponentCallWithRefs(n, "")
				g.writef("%s = append(%s, %s.Root)\n", sliceVar, sliceVar, callVar)
			case *LetBinding:
				g.generateLetBinding(n, "")
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, n.Name)
			case *ForLoop:
				g.generateForLoopForSlice(n, sliceVar)
			case *IfStmt:
				g.generateIfStmtForSlice(n, sliceVar)
			case *GoCode:
				g.generateGoCode(n)
			case *GoExpr:
				elemVar := g.nextVar()
				g.writef("%s := tui.New(tui.WithText(%s))\n", elemVar, n.Code)
				g.writef("%s = append(%s, %s)\n", sliceVar, sliceVar, elemVar)
			}
		}
		g.indent--
		g.writeln("}")
	} else {
		g.writeln("}")
	}
}

// nextVar returns the next unique variable name.
func (g *Generator) nextVar() string {
	name := fmt.Sprintf("__tui_%d", g.varCounter)
	g.varCounter++
	return name
}

// write writes a string without indentation.
func (g *Generator) write(s string) {
	g.buf.WriteString(s)
}

// writef writes a formatted string with indentation.
func (g *Generator) writef(format string, args ...interface{}) {
	g.writeIndent()
	fmt.Fprintf(&g.buf, format, args...)
}

// writeln writes a line with indentation.
func (g *Generator) writeln(s string) {
	if s == "" {
		g.buf.WriteByte('\n')
		return
	}
	g.writeIndent()
	g.buf.WriteString(s)
	g.buf.WriteByte('\n')
}

// writeIndent writes the current indentation.
func (g *Generator) writeIndent() {
	for i := 0; i < g.indent; i++ {
		g.buf.WriteByte('\t')
	}
}

// GenerateString is a convenience method that returns the generated code as a string.
func (g *Generator) GenerateString(file *File, sourceFile string) (string, error) {
	data, err := g.Generate(file, sourceFile)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// ParseAndGenerate parses source code and generates Go code in one step.
// This is a convenience function for simple use cases.
func ParseAndGenerate(filename, source string) ([]byte, error) {
	return parseAndGenerate(filename, source, false)
}

// parseAndGenerateSkipImports is like ParseAndGenerate but uses format.Source
// instead of imports.Process. This is much faster for tests.
func parseAndGenerateSkipImports(filename, source string) ([]byte, error) {
	return parseAndGenerate(filename, source, true)
}

func parseAndGenerate(filename, source string, skipImports bool) ([]byte, error) {
	lexer := NewLexer(filename, source)
	parser := NewParser(lexer)

	file, err := parser.ParseFile()
	if err != nil {
		return nil, err
	}

	gen := NewGenerator()
	gen.SkipImports = skipImports
	return gen.Generate(file, filename)
}

// textElementWithOptions checks if this is a text element that needs options
// extracted from its children for WithText.
func textElementWithOptions(elem *Element) bool {
	if elem.Tag != "span" && elem.Tag != "p" {
		return false
	}
	// Has text content that should go into WithText
	for _, child := range elem.Children {
		switch child.(type) {
		case *TextContent, *GoExpr:
			return true
		}
	}
	return false
}

// skipTextChildren returns true if text element children should not be
// processed as AddChild calls (they're already in WithText).
func skipTextChildren(elem *Element) bool {
	if elem.Tag != "span" && elem.Tag != "p" {
		return false
	}
	// Only skip if there's a single text/expr child that was used for WithText
	if len(elem.Children) != 1 {
		return false
	}
	switch elem.Children[0].(type) {
	case *TextContent, *GoExpr:
		return true
	}
	return false
}

// GenerateToBuffer generates code and writes it to the buffer.
// This avoids an extra allocation compared to Generate().
func (g *Generator) GenerateToBuffer(buf *bytes.Buffer, file *File, sourceFile string) error {
	data, err := g.Generate(file, sourceFile)
	if err != nil {
		return err
	}
	buf.Write(data)
	return nil
}

// generateStateBindings generates Bind() calls for reactive state bindings.
// This is called after all elements are created so the element variables exist.
func (g *Generator) generateStateBindings() {
	if len(g.stateBindings) == 0 {
		return
	}

	g.writeln("")
	g.writeln("// State bindings")

	// Build a map of state variable names to their types
	stateTypes := make(map[string]string)
	for _, sv := range g.stateVars {
		stateTypes[sv.Name] = sv.Type
	}

	for _, binding := range g.stateBindings {
		g.generateBinding(binding, stateTypes)
	}
}

// generateBinding generates a Bind() call for a single state binding.
func (g *Generator) generateBinding(b StateBinding, stateTypes map[string]string) {
	if len(b.StateVars) == 0 {
		return
	}

	// Determine the setter method based on attribute
	setter := g.getSetterForAttribute(b.Attribute)
	if setter == "" {
		return
	}

	if len(b.StateVars) == 1 {
		// Single state variable - direct binding
		stateName := b.StateVars[0]
		stateType := stateTypes[stateName]
		g.writef("%s.Bind(func(_ %s) {\n", stateName, stateType)
		g.indent++
		g.writef("%s.%s(%s)\n", b.ElementName, setter, b.Expr)
		g.indent--
		g.writeln("})")
	} else {
		// Multiple state variables - shared update function
		updateFn := fmt.Sprintf("__update_%s", b.ElementName)
		g.writef("%s := func() { %s.%s(%s) }\n", updateFn, b.ElementName, setter, b.Expr)
		for _, stateName := range b.StateVars {
			stateType := stateTypes[stateName]
			g.writef("%s.Bind(func(_ %s) { %s() })\n", stateName, stateType, updateFn)
		}
	}
}

// getSetterForAttribute returns the element setter method for a given attribute.
func (g *Generator) getSetterForAttribute(attr string) string {
	switch attr {
	case "text":
		return "SetText"
	case "class":
		// Note: class attribute bindings would need SetClass or similar
		// For now, we don't support dynamic class bindings since element
		// doesn't have a SetClass method. This is a future enhancement.
		return ""
	default:
		return ""
	}
}
